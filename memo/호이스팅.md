
java는 컴파일 언어
js는 인터프리터 언어이다

바이트 코드로 변환해 vm에서 실행한다는 점에서 두 언어는 비슷하다
js런타임은 사실상 vm이라고 할 수 있다 

js코드 -> parse -> AST -> 바이트코드 -> VM(interpreter)

바이트 코드는 한줄씩 실행되는데
선언부와 실행부로 나뉜다
선언부는 memory creation phase
실행부는 code execution phase

선언부는 bytecode로 변환된 후 떨어지고
실행부는 인터프리터에 의해 한줄씩 실행된다

따라서 이를 컴파일러라고 해도 무방하다

그럼 이 컴파일, 평가 단계의 순서는 아래와 같다

1. Tokenizer(Lexer)
   - 코드를 토큰 단위로 분해
2. Syntax Analyzer(Parser)
   - 토큰을 구문 트리로 변환
3. AST(Abstract Syntax Tree)
   - 추상 구문 트리 생성
4. Intermediate Code Generator
   - 중간 코드 생성
5. Code Optimizer
   - 코드 최적화
6. Target Code Generator
   - 타겟 코드(바이트코드) 생성

이후 실행부는 다음과 같은 일을 한다
- 코드 평가시의 선언문을 해당 스코프의 상단으로 끌어올려 메모리를 선점, 생성한다 (Linking)


런타임 구조
1. 글로벌 object 생성
   - function declaration, var 선언 메모리 할당
2. 실행 컨텍스트 생성
   - global execution context가 올라간다
   - window.alert할때 window가 글로벌 객체이다


let,const도 호이스팅이 된다
다만, 사용하기 전에 선언이 먼저 되어야 한다
호이스팅 될떄는 Not initialized Yet 상태가 되는데 이렇게 되면 값을 사용할수가 없다

선언문이 없으면 not defined 에러가 난다


코드 원본
```js
console.log(i); // error
let i = 1;
console.log('x=', x);
var x = 1;
console.log(ff, f);
f(); // error
{
  f();
  var x = 2;
  function f() {
    console.log('f>', x, xx);
  }
  const b = 1;
}
function ff() {
  console.log('ff>', y, yy);
}
if (x >= 2) {
  var y = 5;
  let yy = 55;
}
var xx = 100;
ff();
```


```js
// var와 function은 함수레벨 스코프, let,const는 블록레벨 스코프이다
    // function은 object로 등록된다
    // function object는 function declaration이라는 영역에 할당된다
console.log(i); // error: Cannot access 'i' before initialization
let i=1; // 순서 : 1
// -> let i = <not initialized yet> , 메모리를 undefined로 할당
// not initialized yet 은 freshness 상태이다
// undefined + NiY 상태 -> 따라서 값이 할당되기 전이므로 위의 console.log(i)는 error가 난다
console.log('x=',x); // undefined
var x=1; // 순서 : 2
//-> var x = undefined , 메모리를 undefined로 할당 
// 따라서 var은 이 함수의 최상단까지 올라간다
// f(); // error: f is not a function 
{
    f();
    var x=2; 
    function f(){ // 순서 : 3 
    // globalThis.f -> undefined // 호이스팅은 되지만 블록 레벨에만 존재하기 때문에 함수 오브젝트로 등록되지 않는다
        console.log('f called',x,xx);
    } // '블록 레벨의 함수'이기 때문에 이 시점에서야 f는 function object로 등록될 수 없다
    // 블록은 실행될수도 있고 안될수도 있기 때문이다
    const b=1; // -> const b = <not initialized yet>
}
function ff(){ // 순서 : 4
// 이 함수는 전역레벨이기 떄문에 function object로 등록된다

    console.log('ff called',y,yy)
}
if(x>=2){
    var y=5; // 순서 : 5
    // var이므로 블록스코프를 뚫고 일단 undefined로 메모리 할당
    let yy=55; // -> let yy = <not initialized yet>
}
var xx=100; // 순서 : 6
// var아므로 일단 undefined로 메모리 할당
ff();
```

코드 평가 단계
```js
let i = <notInitializedYet>;  // freshness
var x = undefined;
globalThis.f = undefined;  // hoisting, but not fn
function ff() { console.log('ff>', y, yy); }
var y = undefined;
var xx = undefined;
---
console.log(i); // not defined error!!
i = 1; // turn-off freshness!!
console.log('x=', x);
x = 1;
console.log(ff, f);
f(); // not a function error!!
{
  function f() { console.log('f>', x, xx); }
  const b = <notInitializedYet>;
  f();
  x = 2;
  b = 2;
}
if (x >= 2) {
  let yy = <notInitializedYet>;
  y = 5;  yy = 55;
}
xx = 100;
ff();
```

코드 실행 모습

```js
let i = <not initialized yet>
var x = undefined
f = undefined
function ff() { ... }
var y = undefined
var xx = undefined

console.log(i); // Reference error 발생, i is not defined
i=1;
console.log('x=',x); // x= undefined
x=1;
console.log(ff,f); // function ff() {...}, undefined
f(); // Type error 발생, f is not a function
{
 function f() { 
    console.log('f called',x,xx)
  } // 이 시점에서 function object로 등록된다
 const b;
 f(); // 1, undefined 
 x=2;
 b=1;
}
if(x>=2){
 let yy = <not initialized yet>;
 y=5;
 yy=55;
}
xx=100;
ff();  // reference error 발생, yy is not defined
```
hoisting(호이스팅)
호이스팅은 변수와 함수의 선언부를 스코프의 상단으로 옮기는 것
memory creation phase -> execution phase