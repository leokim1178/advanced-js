

화살표 함수는 생성자가 없다
object method와 같이 non-constructor이다
따라서 new 키워드와 함께 사용할 수 없다
```js
const Dog = (name) => {
  this.name = name;
};
const dog = new Dog('뽀삐'); // TypeError: Dog is not a constructor
```

그럼 object method란?
```js
const dog = {
    name: '뽀삐',
    bark: function() {
    console.log(`${this.name}가 멍멍!`);
  },
};
dog.bark(); // 뽀삐가 멍멍!
```
이렇게 object의 프로퍼티로 할당된 함수를 object method라고 한다
이런 경우 this는 해당 object를 가리킨다




```js
$btn1.addEventListener('click', function () {
  console.log('Click11!!!!!', this); // button
});

$btn2.addEventListener('click', () => {
  console.log('Click22!!!!!', this); // window
});
```
위와 같이 버튼의 클릭 이벤트 리스너의 콜백 함수로 일반 함수와 화살표 함수를 각각 전달했을 때
일반 함수에서는 this가 버튼 자신을 가리키지만
화살표 함수에서는 this가 전역 객체(window)를 가리킨다
이는 화살표 함수가 자신만의 this 바인딩을 가지지 않고
외부 스코프의 this를 그대로 가져오기 때문이다



```js
const obj = {
  name: 'ObjName',
  bark1() {
    console.log('1️⃣  bark1 함수 -> this.name : ', this.name);
    const self = this;  // OLD version
    setTimeout( function() {
        // 이 함수는 setTimeout 속에서 실행되지만 클로저이다( self 변수를 참조)
      console.log('1️⃣  bark1 함수 (setTimeout 내에서) -> self.name : ', self.name); 
      // 결과 : 'ObjName'
      console.log('1️⃣  bark1 함수 (setTimeout 내에서) -> this : ', this); 
      // 결과 : Timeout{...}
    }, 1000);     // .bind(this)
  },
  bark2() { 
    console.log('2️⃣  bark2 함수 -> this.name : ', this.name);

    setTimeout(() => { // 여기서는 화살표 함수!
      console.log(' 2️⃣  bark2 함수 (setTimeout 내에서) -> this.name : ', this.name);
    }, 1000);
  },
  bark3() { 
    function innerFn() {
      console.log('3️⃣  bark3 함수 (innerFn 내에서) -> this : ', this);
    } // 이건 함수 선언문일 뿐, 호출이 아니다
    // 또한 일반함수이기 떄문에 화살표 함수처럼 상위 스코프의 this를 물려받지 않는다.
    // innerFn은 bark3의 내부 함수이지만, 일반 함수로서 호출되었기 때문에
    // 따라서 this는 전역 객체를 가리킨다 (strict mode에서는 undefined)
    // 이 함수는 생성자를 사용한 일반 함수이기 때문에 binding이 되므로  <ref *1> Object [global] {...} 이 찍히는 것
    innerFn();
  },
  bark4: () => {
    console.log('4️⃣  bark4 함수 -> this.name : ', this.name); 
    // this의 바인딩은 일어나지 않는다
    // 왜냐, 화살표 함수는 this를 가질 수 없기 때문이다
    console.log('4️⃣  bark4 함수 -> this : ', this); 
    // 결과 : {} (Node.js 환경에서의 전역 객체)
    // 그럼 왜 innerFn처럼 전역 객체가 아닌 {}일까?
    // 화살표 함수는 자신만의 this 바인딩을 가지지 않기 때문이다
    // 따라서 상위 스코프의 this를 그대로 사용한다
    // 이 경우 상위 스코프는 파일 전체 스코프이다 (모듈 스코프)
    // 모듈 스코프에서의 this는 빈 객체 {} 이다
  }, // bark4의 소유자(obj)의 (Lexical Environment = 전역) 의 this => globalThis
};

obj.bark1(); // bark1()의 바인딩은 obj 
// 1.bark1의 this.name은 'ObjName'
// setTimeout 내부 함수의 this는 Timeout 객체
// 하지만 self 변수는 obj를 가리키므로 self.name은 'ObjName'
obj.bark2();
// 2.bark2의 this.name은 'ObjName'
// setTimeout 내부의 **화살표 함수**는 상위 스코프(bark2)의 this를 그대로 사용한다
// 따라서 this.name은 'ObjName'
obj.bark3();  
obj.bark4();


setTimeout(() => console.log("##############################"), 1000);
```

이렇게 난해하기 때문에 실무에서는 화살표 함수 사용을 지양하는 편이다

```js
const obj = {
  name: 'ObjName',
  bark() {     // good!(호출한 객체)
    console.log('bark=', this.name);
  },
  bark2: () => // bad!! (this=전역/module)
   console.log('bark2=', this.name),
};

obj.bark();
obj.bark2();
```

굳이 써야한다면 this를 사용하지 않는 용도일 때이다
그렇다면 굳이 객체 내에 쓸 필요는 없을것이다
밖으로 빼면 되지 



```js
const Dog = function(name) {
  console.log(name +" : "+`\n`,this, ' / ', new.target, ' / ',
              this instanceof Dog);
  this.name = name;
  this.bark = function () {
    console.log('1️⃣  bark=', new.target, ' / ', this.name, ' / ', name);
  };
  this.bark2 = () =>
    console.log('2️⃣  bark2=', new.target, ' / ', this.name, ' / ', name);
}

// Dog.bark();
// 위에서 Dog는 함수를 선언한 것일 뿐, 호출한 것이 아니다.
// 따라서 하나의 instance라고 할 수 없기 때문에 존재하지 않는다는 에러가 난다.
const dog = Dog('🐶 not new Dog');
// 결과 : <ref *1> Object [global] {...} / undefined /  false
console.log('🐶 not new Dog type=', typeof dog); 
// 결과 : type= undefined
// 일반 함수로서 호출되었기 때문에 반환값이 없다
const newDog = new Dog('🐕 new Dog');
// 결과 :  Dog {} / [Function: Dog] / true
console.log('🐕 new Dog type=', typeof newDog); 
// 결과 : type= object
// 생성자 함수로서 호출되었기 때문에 객체가 반환된다
newDog.bark(); 
// 결과 : 1️⃣  bark= undefined / 🐕 new Dog / 🐕 new Dog
// 일반 함수의 경우 new로 호출되지 않았기 때문에 new.target은 undefined가 된다
// this는 생성된 객체를 가리키기 때문에 this.name은 '🐕 new Dog'이 된다
newDog.bark2(); 
// 결과 : 2️⃣  bark2= [Function: Dog] / 🐕 new Dog / 🐕 new Dog
// 화살표 함수의 new.target은 상위 스코프의 new.target을 따르기 때문에 
// 상위 스코프인 newDog의 new.target인 [Function: Dog]이 된다
// 화살표 함수는 this 바인딩도 상위 스코프를 따르기 때문에 this.name도 '🐕 new Dog'이 된다
```