
구조분해 할당은 익숙하게 많이 했지만 공부하다가 생소하게 느껴졌던 것들만 메모해보자

변수 스왑
```js
const arr = [1,2,3,4,5];
let [a,b,...rest] = arr; // a=1, b=2, rest=[3,4,5]
[a,b] = [b,a];
console.log(a,b); // 2 1
```
stack 상황을 살펴보자
--|--|--
[⍺] | a | &1
[β] | b | &2

위와 같이 ⍺에는 a가 &1번지를 가리키고, β에는 b가 &2번지를 가리킬때
⍺에는 &2를, β에는 &1을 넣어주는 방식으로 스왑이 이루어진다.




Default Value Destucturing
```js
const { id,name,addr = 'seoul' } = { id:1, name:'kim', addr:'busan' }
const [a,b,c=30] = [10,20];
```
위와 같이 객체나 배열 디스트럭처링에서 기본값을 지정할 수 있다
만약 addr이나 c가 undefined라면 기본값 'seoul'과 30이 각각 들어가게 된다

Argument Destucturing
```js
function f1( { id, name, addr = 'seoul' } ) {}
```
흔히 이렇게 쓰는 패턴도 destucturing의 일종이다
위와 같이 매개변수를 객체 디스트럭처링으로 받으면
함수를 호출할 때 객체의 프로퍼티 순서에 상관없이 값을 전달할 수 있다
물론 addr과 같이 기본값도 지정할 수 있다


Array to Object Destucturing
```js
const arr = [1,2,3];
{...arr}  // {0:1, 1:2, 2:3}
```
위와 같이 배열을 객체로 변환할 수 있듯
아래와 같이 destucturing도 가능하다
```js
const {'0':first, '1':second, '2':third} = arr; // first=1, second=2, third=3
```
그럼 length 프로퍼티도 destucturing이 될까?
```js
const {'0':first, '1':second, '2':third, length: arrLength} = arr; 
arrLength; // 3
```
length 프로퍼티도 destucturing이 가능하다

```js
{...arr}// {0:1, 1:2, 2:3}
```
위와 같이 했을때는 enumerable한 프로퍼티만 복사되기 때문에 length는 복사되지 않는다
그러나 destucturing시에는 length 프로퍼티도 복사할 수 있다


필드 이름 변경
```js
const user = { id: 1, name: 'kim', addr: {city: 'seoul',road: 'main'} };
const mainField = user.id >5? 'name' : 'addr';
const { [mainField]: target } = user;
```
필드는 []로 감싸면 필드명을 동적으로 지정할 수 있다
위와 같이 destucturing시 필드 이름을 동적으로 지정해 활용할 수 있다
user.id가 5보다 크지 않으므로 mainField는 'addr'이 되고
target에는 user.addr이 들어가게 된다


```js
const [ , , d ] = [ 1, 2, 3 ];  // d = ?
const [ , x, , y, , z ] = [ 1, 2, 3, 4, 5, 6 ];
```
위와 같이 비워놓는 것도 가능


### Default Value Destucturing에서 주의할점
```js
const { id, name = 'Hong' } = { id: 1, name: '' }; // id = ?, name = ? ''
// id = 1, name = ''
```
name이 ''이기 때문에 기본값이 적용되지 않는다
```js
const { id, name = 'Hong', addr = 'xx' } = { id: 1, name: undefined, addr: null }; // id = ?, name = ?, addr = ?
// id = 1, name = 'Hong', addr = null
```
기본값은 undefined일때만 적용된다
따라서 name이 ''이거나 addr이 null인 경우에는 기본값이 적용되지 않는다

```js
const obj = {i: 1, j: 2, l: 3, m: 4, n: 5};
let { j, i, k = i * j * n } = obj;  // j = ?, i = ?, k = ? 
// ReferenceError: Cannot access 'i' before initialization
```
위와 같이 destucturing시 기본값에 다른 필드를 참조할 수 없다
기본값은 destucturing 대상이 모두 평가된 후에 평가되기 때문에
기본값에 참조된 i,j는 아직 초기화되지 않은 상태이기 때문이다    

```js
const obj = {i: 1, j: 2, l: 3, m: 4, n: 5};
const { k = i * 10, i, j } = obj;    // k = ?  i가 hoisting 됐으니까 'NiY'
// ReferenceError: Cannot access 'i' before initialization
```
마찬가지로 위와 같이도 참조할 수 없다


```js
let q, s, r;
({ r = q * 10, q, s } = {q: 10, s: 20});  // q = ?, s = ?, r = ?
{ q, r, s }  // { q: 10, r: NaN, s: 20 }
```
위와 같이 destucturing 할당문에서는 기본값에 다른 변수를 참조할 수 있다
이는 할당문이 평가되는 시점에는 q가 이미 초기화된 상태이기 때문이다
따라서 r은 q * 10이 평가되는데 이 때 q는 undefined이므로 r은 NaN이 된다