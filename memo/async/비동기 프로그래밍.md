자바스크립트는 싱글 스레드

자바 vs 자바스크립트

자바는 멀티스레드 한개의 프로세스가 두가지 이상의 일을 함
싱글스레드의 장점 : 콜스택이 하나밖에 없음 -> 한번에 하나의 일만 처리
그래서 백그라운드-WebAPI가 필요했던것
백그라운드에게 I/O에 대해서 맡김
I/O : 파일처리, 네트워크처리, 타이머처리
-> 이걸 OS의 커널에게 맡김
이 작업이 끝나면 콜백함수를 콜스택에 넣어줌

웹서버의 최강자 : Nginx
-> 싱글쓰레드, 멀티스레드인 Apache보다 훨씬 빠름

자바가 많이 빨라지긴했지만 처리속도는 노드가 훨씬 빠름
그런데 많은 처리를 할수 있다는 것이지 응답속도가 빠르다는것은 아님
-> 응답속도는 자바가 더 빠름

응답 제일빠른것 -> Php 싱글프레스 싱글쓰레드
단점은 많은 요청이 들어오면 느려짐

I/O작업을 수행하는 비동기 함수는 반드시 Background Web API로 보내진다

JS Engine : V8, SpiderMonkey, Chakra
JS Runtime (JS Engine을 품고 있음): Browser, Node.js, Deno

MICRO-TASK QUEUE

- 프로미스 콜백 함수들이 대기하는 곳

MACRO-TASK QUEUE

- setTimeout, setInterval 콜백 함수들이 대기하는 곳

이벤트 루프는 항상 MICRO-TASK QUEUE를 먼저 확인한다

전통적 비동기 Callback 방식

### Promise static methods

#### Promise.resolve

- 이미 존재하는 값 Promise.resolve(x).then(val => console.log(val));
  ⇐⇒ new Promise((resolve) => resolve(x))
  .then(console.log);

#### Promise.reject

- Promise.reject(new Error('...')).catch(console.error);
  ⇐⇒ new Promise((\_, reject) => reject(new Error('...')))
  .catch(console.error);

#### 어떨 때 사용할까?

##### Promise.resolve

1. **이미 값을 알고 있을 때 - 캐시된 데이터 즉시 반환**

```javascript
const cache = new Map();

function getUserData(userId) {
  // 캐시에 데이터가 있으면 즉시 Promise로 반환
  if (cache.has(userId)) {
    return Promise.resolve(cache.get(userId));
  }

  // 없으면 API 호출
  return fetch(`/api/users/${userId}`)
    .then((res) => res.json())
    .then((data) => {
      cache.set(userId, data);
      return data;
    });
}

// 사용 - 캐시 여부와 관계없이 동일하게 then으로 처리
getUserData(1).then((user) => console.log(user));
```

2. **비동기 처리 흐름 유지 - 동기 값을 비동기처럼 다루기**

```javascript
function validateAndFetch(id) {
  // id가 유효하지 않으면 동기적으로 null 반환하지 않고
  // Promise로 감싸서 일관된 비동기 흐름 유지
  if (!id || id < 0) {
    return Promise.resolve(null);
  }

  return fetch(`/api/data/${id}`).then((res) => res.json());
}

// 항상 Promise 체인으로 처리 가능
validateAndFetch(-1)
  .then((data) => data || "데이터 없음")
  .then(console.log);
```

##### Promise.reject

1. **입력 검증 실패 시 즉시 에러 반환**

```javascript
function processPayment(amount, cardNumber) {
  // 유효성 검증 실패 시 즉시 에러
  if (amount <= 0) {
    return Promise.reject(new Error("금액은 0보다 커야 합니다"));
  }

  if (!cardNumber || cardNumber.length !== 16) {
    return Promise.reject(new Error("유효하지 않은 카드 번호입니다"));
  }

  // 검증 통과 시 실제 처리
  return fetch("/api/payment", {
    method: "POST",
    body: JSON.stringify({ amount, cardNumber }),
  }).then((res) => res.json());
}

// 사용 - 검증 실패와 API 실패 모두 catch에서 처리
processPayment(-100, "1234")
  .then((result) => console.log("결제 성공:", result))
  .catch((error) => console.error("결제 실패:", error.message));
```

2. **특정 조건에서 비동기 작업 중단하고 에러 반환**

```javascript
function fetchUserWithPermission(userId, currentUser) {
  // 권한 체크 - 실패 시 즉시 에러
  if (!currentUser.isAdmin) {
    return Promise.reject(new Error("권한이 없습니다"));
  }

  return fetch(`/api/users/${userId}`)
    .then((res) => res.json())
    .then((user) => {
      // 조건부 에러 발생
      if (user.status === "deleted") {
        return Promise.reject(new Error("삭제된 사용자입니다"));
      }
      return user;
    });
}

// 사용 - 모든 에러를 동일하게 처리
fetchUserWithPermission(123, { isAdmin: false })
  .then((user) => console.log(user))
  .catch((err) => console.error("오류:", err.message));
```

**핵심 포인트:**

- `Promise.resolve`: 동기 값을 Promise로 감싸서 일관된 비동기 흐름 유지
- `Promise.reject`: 즉시 에러를 발생시켜 `.catch()`로 통합 에러 처리
- 둘 다 코드의 일관성과 가독성을 높이는 데 사용

### Promise state

- pending
  - 진행중 성공/실패 여부 모름
- fulfilled
  - 성공상태
  - resolve가 불려진 상태
- rejected
  - 실패상태
  - reject가 불려진 상태

### Promise.all

- Promise가 여러개가 있을때
- 모든 Promise가 fulfilled가 되어야 then이 실행됨
- 하나라도 rejected가 되면 catch가 실행됨
- 순서 보장

### Promise.allSettled

- Promise가 여러개가 있을때
- 성공이건 실패건 모두 settled가 되면 then이 실행됨
- 순서 보장

### Timer

timer를 호출하면 커널이 받음
커널은 타이머를 하나씩 만들고 id를 부여한다
이 id를 js엔진에게 다시 준다
js엔진은 이 id를 알고 있다
이 id를 clearInterval하면 timer에게 다시 보낸다

AbortController라는 것이 있다
Node는 event Driven 방식이다
interrupt가 오면 halt상태를 풀기 위해 call시킨다
이걸 emit이라고 한다
emit이 일어나면 event가 발생한다
받는 쪽에서는 on으로 받는다
어쨋든 abortcontroller에서 abort를 하면 그 Promise는 취소가 된다

### Promise.race

- 가장 빠른 것 하나만
- 하나라도 실패시 catch로(Promise.all과 동일)
- 에러가 발생이 중요한 경우일때
- 시세,환율 등 중에서 가장 빠른거 하나만 필요할때 쓰면 좋다
- ex) kb증권, nh투자, 신한금융, 미래에셋 등에서 환율정보를 받아올때

### Promise.any

- 제일 빨리 성공한 하나만
- 하나라도 성공시 바로 then으로
- 에러가 상관없을때
