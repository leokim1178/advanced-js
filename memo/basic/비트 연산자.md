
## 비트 연산
0b -> 2진수 b는 binary
0o -> 8진수 o는 octal
0x -> 16진수 x는 hexadecimal

따라서
```js
let a = 0b1010; // 10진수 10
let b = 0b1100;   // 10진수 12
```
위와 같이 10진수를 여러 진수로 표현할 수 있다

그럼 연산을 해보자

```js
a & b; // 1010 & 1100 = 1000
a | b; // 1010 | 1100 = 1110
a ^ b; // 1010 ^ 1100 = 0110
~b;    // ~1100 = 0011
```
&는 and 연산자로 두 비트가 모두 1일때만 1이 된다  
|는 or 연산자로 두 비트 중 하나만 1이어도 1이 된다  
^는 xor 연산자로 두 비트가 서로 다를때만 1이 된다  
~는 not 연산자로 비트를 반전시킨다  

```js
a >> 1;  // 10 >> 1 = 5  (0b1010 >> 1 = 0b0101)
a >>> 1;  // 10 >>> 1 = 5  (0b1010 >>> 1 = 0b0101)
a << 1;  // 10 << 1 = 20 (0b1010 << 1 = 0b10100)
```
>>는 부호 있는 오른쪽 시프트 연산자로 부호 비트를 유지하며 오른쪽으로 비트를 이동시킨다  
>>>는 부호 없는 오른쪽 시프트 연산자로 부호 비트와 상관없이 오른쪽으로 비트를 이동시킨다  
<<는 왼쪽 시프트 연산자로 왼쪽으로 비트를 이동시킨다

사용 예시
Read, Write, Execute 권한 설정을 예시로 작성해보자
```js
const R =1; W=2; E=4; // 0b001, 0b010, 0b100
let auth = parseInt('011',2); // 0b011 = 3
const hasWriteAUth= (auth & W) 
const hasExecuteAuth = (auth & E)
const hasReadAndExecuteAuth = (auth & (R|E))
console.log(hasWriteAUth); // 2 (true)
console.log(hasExecuteAuth); // 0 (false)
console.log(hasReadAndExecuteAuth); // 1 (true)
auth = auth ^ E; // 권한 추가
```

## 숫자 
정수
```js
Number.MIN_SAFE_INTEGER; // -(2**53 -1)
Number.MAX_SAFE_INTEGER; // 2**53 -1
```
범위를 넘는 정수는 BigInt 타입을 사용해야 한다
```js
const bigIntNum = 9007199254741991n; // n을 붙여서 BigInt 타입으로 만듦
```


```js
0.1 + 0.2 // 0.30000000000000004
0.1 + 0.2 === 0.3 // false
0.1 + 0.2 - 0.3 // 5.551115123125783e-17
```
위와 같이 부동소수점 오차가 발생할 수 있다
이를 해결하기 위해 아래와 같이 한다

```js
Number((0.1+0.2).toFixed(1))
Number((0.1+0.2).toFixed(1)) === 0.3 // true
// 또는
+(0.1 + 0.2).toFixed(1) 
+(0.1 + 0.2).toFixed(1) === 0.3 // true
```

```js
2.5 % 1 // 정수 부분을 없애겠다는 뜻
2.4 % 1 // 0.39999999999999999
// 이것도 부동소수점 오차가 발생할 수 있다
+(2.4 % 1).toFixed(1) // 0.4
```

Number.EPSILON은 1과 1보다 큰 수 중에서 가장 작은 수의 차이를 나타낸다
따라서 오차없는 값비교를 위해 다음과 같이 사용할 수 있다
```js
function isEqual(a, b) {
  return Math.abs(a - b) < Number.EPSILON;
} 
isEqual(0.1 + 0.2, 0.3); // true
```


### 착각하기 쉬운 연산들
```js
false =='0' // true
// 이유는 비교하는 순간 '0'이 숫자 0으로 변환되면서 발생하는 문제다
false ==='0' // false

!!'0' // true
// 비교할때는 변환되지만 이 때는 문자열 '0'으로 판단하기 떄문에 true가 된다

false == '   0  ' // true
// '   0  '이 숫자 0으로 변환되면서 trim을 자동으로 해주면서 0으로 변환된다

isFinite(0) // true             
isFinite(Infinity) // false  
isFinite(null) // true
// null이 숫자로 바뀌면 0이 되기 떄문에 유한하다
isFinite('') // true
// ''이 숫자로 바뀌면 0이 되기 떄문에 유한하다

isFinite(NaN) // false
// NaN은 숫자가 아니기에 유한하지 않다
isFinite('hello') // false
// 'hello'는 숫자로 변환되지 않기에 NaN이 되어 유한하지 않다

[] == 0 // true
+[] // 0
// [] 자체는 truthy값이다 
// 그러나 []이 숫자로 변환되면 ''이 되고 ''은 다시 숫자로 변환되면 0이 되기 떄문에 true가 된다
[] === 0 // false
// 엄격한 비교이기에 타입이 다르면 false가 된다
!![] // true
// []은 truthy한 값이기에 true가 된다

!!0 // false
// 0은 falsy한 값이기에 false가 된다
```
위 케이스들은 몰랐던 내용인데 짚고 넘어가자
물론 위와같은 코드는 지양하는게 좋다