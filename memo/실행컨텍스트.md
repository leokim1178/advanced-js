


실행 컨텍스트 타입들
a. 전역 실행 컨텍스트(Global Execution Context)
- 자바스크립트 코드가 처음 실행될 때 생성되는 실행 컨텍스트
- 브라우저 환경에서는 전역 객체인 window 객체를 가리킴
- 오직 하나만 존재
b. 함수 실행 컨텍스트(Function Execution Context)
- 함수가 호출될 때마다 생성되는 실행 컨텍스트
- 여러 개가 동시에 존재할 수 있음
- 함수마다 고유한 실행 컨텍스트가 생성됨
c. eval 실행 컨텍스트(eval Execution Context)
- eval 함수가 실행될 때 생성되는 실행 컨텍스트
- eval 함수는 보안상의 이유로 권장되지 않음
d. Excution Context Stack(실행 컨텍스트 스택)
- 실행 컨텍스트는 스택 자료구조로 관리됨
- 가장 마지막에 생성된 실행 컨텍스트가 현재 실행 중인 컨텍스트
- 실행 컨텍스트가 종료되면 스택에서 제거되고 이전 컨텍스트로 돌아감

1. Creation Phase
   1. lexical environment (let / const and strict-function)
      - environment record
        - DeclarativeRecord
          - const/let
        - ObjectEnvironmentRecord
          - var and function
   2. globalThis 바인딩 (전역에서는 전역 객체를 가리킴)
2. Execution Phase


```js
const c=1;
var v=2;
function f(){
    var v=3;
    const c=11;
    let l=1;
    console.log(c,v,l); // 11 3 1
}
f();
```


디테일한 실행순서
ECS(Execution Context Stack)의 가장 밑바닥에는 항상 전역 실행 컨텍스트가 존재한다
1. Global Execution Context
   - Global Lexical Environment를 참조하고 있다
   1. Creation Phase 시작
      1. 우선 `c`는 const이므로 DeclarativeRecord에 생기고 undefined로 세팅된다.
      2. `v`는 var이므로 GlobalObjectEnvironmentRecord에 생기고 undefined로 세팅된다.
      3. `f` 는 function으로, function declaration에 추가되고, GlobalObjectEnvironmentRecord에 함수명이 생기고 함수 코드를 저장한다.
         - 이 떄 [[Environment]] 라는 슬롯이 생긴다. 
   2. Execution Phase 시작
      1. `c`에 1이 할당된다.
      2. `v`에 2가 할당된다.
      3. `f` 함수가 호출된다.


f에는 function lexical environment가 필요하다
이는 GEC 다음으로 ECS에 쌓이게 된다
이 context가 종료되면 Stack에서 pop될것이고 스택포인터가 GEC를 가리키게 될 것이다


### 참고할점
ES6에서는 Function Environment Record는 Lexical Environment와 Variable Environment를 포함한다
위의 코드로 예를 들면
`c`와 `l`은 Lexical Environment에 저장되고
`v`는 Variable Environment에 저장된다
ES6 이전에는 Function Environment Record가 Variable Environment만 포함했다
이후에 declarative environment record가 추가되면서 위와 같은 변화가 생겼다


1. Global Object 생성
2. GlobalLexicalEnvironment, ObjectEnvironment, DeclarativeRecord, GlobalVariableEnvironment 생성
3. Function이 생성될 때마다 FunctionObject가 생성되고, 이 객체는 [[Environment]] 슬롯을 가지며, 이는 Function이 선언된 환경을 가리킨다
4. Function이 호출될 때마다 새로운 Execution Context가 생성되고, 이 때 FunctionEnvironmentRecord가 만들어지고 이는 FunctionLexicalEnvironment와 FunctionVariableEnvironment를 포함한다


```js
function fn(){
    let l1=1;
    var v1=2;
    function ifn(){
        return l1;
    }
    if(v1>1){
        let l2=3;
        var v2=4;

    }
    return ifn();
}
var y=fn.apply({x:10}); 
console.log(y()); 
```
apply는 fn.bind({x:10})()와 동일하다
즉 fn 함수 내부에서 this는 {x:10}이 된다
function declaration 내부에서는 [[BoundThis]] 슬롯이 생성되고, 이 슬롯은 this로 바인딩된다
[[BoundThis]] 는 {x:10}을 가리키게 된다
```js
obj={
    x:1
}
obj2 = obj
obj2.x =10;
```
만약 위와 같이 했을때, obj, obj2는 같은 주소를 보고 있다
그렇다면 obj.x도 10이 될 것이다
그래서 obj에 apply를 사용해서 새롭게 할당했을때, obj와 obj2는 다른 주소를 가리키게 되면서도
obj2의 functionObject의 [[BoundThis]] 슬롯은 여전히 obj를 가리키게 되기 떄문에
원본을 해치지 않으면서 this 바인딩을 바꿀 수 있다

y()에서부터는 
BoundedFnObj가 실행된다
그럼 lexicalEnv가 만들어진다
lexicalEnv, variableEnv, outerLexicalEnvRef
l1 lexicalEnv에
v1는 variableEnv에
fn.ifn은 FunctionDeclaration에
fn.ifn은 Bfn의 environmentRef를 가리킴
if block에서부터는 BlockLexicalEnv가 만들어짐
l2는 BlockLexicalEnv에
v2는 block을 뚫고 올라가서 variableEnv에
ifn은 variableEnv에 위치하고 functionDeclaration의 함수코드를 가리킴
이제 y는 ifn의 functionObject를 가리킨다
ifn을 리턴했는데 ifn은 l1을 보고있다
이렇게 되면 Bfn은 Stack에서는 사라지지만 ifn은 l1을 참조할 수 있기 때문에 Bfn의 LexicalEnv는 GC의 대상이 될 수 없다
물론 Stack에서는 사라졌기 때문에 `y()`의 실행컨텍스트가 생성된다
y() 실행 이후 y() 실행컨텍스트는 pop되고 이전 실행컨텍스트로 돌아간다
이제 functionDeclaration에 있는 ifn은 더이상 참조하는 곳이 없기 때문에 GC의 대상이 된다


실행컨텍스트 (ES2025)
FunctionEnvironmentRecord가 DeclarativeEnvironmentRecord 타입으로 합쳐졌다
따라서 functionEnvironmentRecord에는 이제 variableEnvironmentRecord가 없다

GlobalEnvironmentRecord(inner-field)
- objectRecord : BindingObject/IsWithEnvironment
- declarativeRecord : const/let/fn/module
- globalThisValue : 전역 thisValue
- varNames : 식별자 List
- OuterEnv : null

FunctionObject
- [[Environment]] 외 14개 슬롯
- PrivateEnvironment 

FunctionEnvironmentRecord(inner slot)
- [[FunctionObject]] 
  - [[Environment]] 슬롯이 가리키는 FunctionObject
  - [[PrivateEnvironment]] 슬롯이 가리키는 PrivateEnvironment
  - [[FormalParameters]] 슬롯이 가리키는 FormalParameters
  - [[ECMAScriptCode]] 함수의 본체를 정의하는 소스 코드의 root(파싱된 AST트리의 루트) parse node 
  - [[ConstructorKind]] 'base' or 'derived' 상속받은 클래스인지 아닌지 여부
  - [[Realm]] Builtin 내장 객체들
  - [[ScriptOrModule]] 함수가 정의된 스크립트 또는 모듈
  - [[ThisMode]] this가 해석되는 방식을 나타냄 
    - lexical : 상위 스코프의 this
    - strict : 바인딩된 객체
    - global : 전역 객체
  - [[Strict]] 'use strict'인지 아닌지 여부
  - [[Fields]] 함수가 클래스인경우 non-static필드를 나타내는 레코드의 리스트

BoundFunctionObject(inner slot)
- [[BoundTargetFunction]] : 바운딩으로 감싼 원본 함수 객체
- [[BoundThis]] : 감싼 함수를 호출했을때 항상 this로 전달되는 값
- [[BoundArguments]] : 바운드된 인수들의 리스트
- [[Call]] : 함수 호출 시 실행되는 내부 메서드

GlobalEnvironmentRecord(inner-field)
- [[ObjectRecord]] : global built-in bindings, FunctionDeclaration, GeneratorDeclaration, AsyncFunctionDeclaration, AsyncGeneratorDeclaration VariableDeclaration bindings 가 포함된 전역 객체 참조
- [[DeclarativeRecord]] : FunctionDeclaration, GeneratorDeclaration, AsyncFunctionDeclaration, AsyncGeneratorDeclaration, VariableDeclaration 바인딩을 제외한 전역 코드의 모든 선언에 대한 바인딩을 포함 => **let, const**로 선언된 식별자
- [[GlobalThisValue]] : 전역 스코프의 this가 반환하는 값 (Global Object)
- [[VarNames]] : 함수(Function, Generator, AsyncFunction, AsyncGenerator) 또는 변수 선언에 바인딩된 문자열 리스트 => 식별자 리스트 (Map 구조)
- [[OuterEnv]] : null
FunctionEnvironmentRecord(inner-field)
- [[FunctionObject]] : Function Object에 대한 참조
- [[NewTarget]] : new 생성자 함수로 호출한 경우(또는 클래스인 경우) Function Object에 대한 참조그렇지 않은 경우 undefined
- [[ThisValue]] : 함수 호출할 때 사용되는 this 값. this를 바인딩하지 않으면 Global Object를 참조(arrow function이면 비어있음!)
ex) fn.call({ id: 1 }) => fn()함수 내의 this는 { id: 1 }
- [[ThisBindingStatus]] : this 바인딩 상태
  - lexically bound : 화살표 함수에서 this가 상위 스코프에서 바인딩된 경우
  - initialized : this가 바인딩된 경우
  - uninitialized : this가 아직 바인딩되지 않은 경우 (클래스 생성자에서 super() 호출 전에 접근하는 경우)
- [[OuterEnv]] : 외부 렉시컬 환경에 대한 참조

```js
function fn() {
  let l1 = 1;
  var v1 = 2;
  function ifn() {
    return this?.x ?? 0 + l1;
  }
  if (v1 > 1) {
    let l2 = 3;
    var v2 = 4;
    console.log(v1, v2);
  }

  return ifn;
}

var xf = fn();
var y = xf.bind({ x: 10 });
let x = 1;
console.log(y(), x);
```


위의 예시코드로 2025버전으로 설명
fn이 functionDeclaration에 등록된다
var y가 GO에 등록된다
x는 let이니 declarativeRecord에 등록된다
이제 fn이 실행되면 fn의 functionEnvironmentRecord가 생성된다
fn의 [[FunctionObject]] 슬롯은 functionDeclaration에 등록된 fn을 가리킨다
이제 ECS에 fn의 실행컨텍스트를 쌓는다
l1,v1은 fn의 functionEnvironmentRecord의 declarativeRecord에 등록된다
ifn은 functionDeclaration에 등록된다
ifn의 [[Environment]] 슬롯은 fn의 functionEnvironmentRecord를 가리킨다
if block이 실행되면 blockEnvironmentRecord가 생성된다
l2 blockEnvironmentRecord에 등록된다
v2는 함수스코프니까 fn의 functionEnvironmentRecord의 declarativeRecord에 등록된다
이제 fn은 ifn을 리턴한다
여기까지 평가단계 끝
l1에 1, v1에 2, l2에 3, v2에 4가 할당된다
이제 BlockEnvRec은 GC의 대상이 된다
ifn을 리턴했다
GO에 xf가 존재할것이고 이 xf는 ifn을 가리킨다
이 ifn의 [[Environment]] 슬롯은 fn의 functionEnvironmentRecord를 가리킨다
따라서 fn의 functionEnvironmentRecord는 GC의 대상이 되지 않는다
물론 실행스택은 pop된다
이제 새로운 bindedifn이 생기고 y가 이 bindedifn을 가리킨다
이 bindedifn의 [[BoundTargetFunction]] 슬롯은 ifn을 가리킬 것이다
[[BoundThis]] 슬롯은 {x:10}을 가리킬 것이다
이후 x=1이 선언되고 할당된다
이제 y()가 호출된다
y()의 실행컨텍스트가 생성된다
this.x는 10이 될것이다
따라서 최종 출력은 10,1이 될 것이다