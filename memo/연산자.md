# JS 연산자 심화

일반적인 연산자에 대한 설명은 생략하고 JS의 연산자에 대해 몰랐던 내용이나 헷갈릴만한 내용을 다룰 예정이다
## 템플릿 리터럴과 콤마-그룹 연산자
###  템플릿 리터럴
template literal의 구조
내부에서는 string concatnation이 일어난다
```js
const name = "홍길동";
const message = `안녕하세요, ${name}님! 환영합니다.`;
```
위와 같은 코드가 있을 때 내부적으로는 다음과 같이 처리된다
```js
const name = "홍길동";
const message = "안녕하세요, " + name + "님! 환영합니다.";
```

### 콤마-그룹 연산자
괄호 안에 하나의 스코프가 존재한다고 보면 될것 같다
```js
let q = (p=x=1,y=2, z=3);
``` 
위와 같은 코드가 있을 때
1. x에 1이 할당된다
2. x의 값이 p에 할당된다
3. y에 2가 할당된다
4. z에 3이 할당된다
5. 마지막으로 z의 값이 q에 할당된다
따라서 q의 값은 3이 된다

```js
let q = (p = (x = 1), (y = 2), (z = y+3));
```
이 경우에는
1. x에 1이 할당된다
2. x의 값이 p에 할당된다
3. y에 2가 할당된다
4. y+3의 값인 5가 z에 할당된다
5. 마지막으로 z의 값이 q에 할당된다
따라서 q의 값은 5가 된다

```js
let q = ((p = (x = 1)), ((y = 2), (z = y++)));
```
이 경우에는
1. x에 1이 할당된다
2. x의 값이 p에 할당된다
3. y에 2가 할당된다
4. y++의 우선순위가 할당 연산자보다 낮기 때문에 y++의 값인 2가 z에 할당된다 (y는 이후에 3이 됨)
5. 마지막으로 z의 값이 q에 할당된다
따라서 q의 값은 2가 된다

```js
let q = ((p = (x = 1)), ((y = 2), (z = ++y)));
```
이 경우에는
1. x에 1이 할당된다
2. x의 값이 p에 할당된다
3. y에 2가 할당된다
4. ++y의 값인 3이 z에 할당된다 (y는 3이 됨) 
5. 마지막으로 z의 값이 q에 할당된다
따라서 q의 값은 3이 된다

위의 경우는 헷갈릴만하다
따라서 가급적 다음과 같이 명확하게 하는것이 오해의 소지가 없다 
```js
let q = ((p = (x = 1)), (y = 2), (y+=1) (z = y));
``` 

```js
let a =1, b=2;
let c = (a++,b++)
// c의 값은? -> 2
// a는 2, b는 3이 되지만 b++의 우선순위가 = 할당 연산자보다 낮기에  
// a는 2, b는 3인 상태... 따라서 c는 b++의 이전 값인 2가 된다

let d = (a--, b+a);
// a가 우선 감소되기에 a는 1이 되고
// b는 이전에 3이기에
// d는 b+a = 3+1 = 4가 된다
```
물론 , 연산자는 가급적 사용하지 않는것이 좋다
가독성이 떨어지고 헷갈릴 소지가 많다
이런 기능이 있다는 것만 기억하고 넘어가자

### **연산자
```js
console.log(2 ** 3); // 8
console.log(2 ** 3 ** 2)
```
위와 같을 때 어떻게 계산될까
1. 3**2가 먼저 계산된다 (지수 연산자는 오른쪽 결합법칙을 따름) -> 9
2. 2**9가 계산된다 -> 512
따라서 결과는 512가 된다
뒤의 **연산을 먼저하기 떄문에 주의하자
앞의 **연산을 먼저하고 싶다면 괄호로 묶어주자
```js
console.log((2 ** 3) ** 2); // 64
```

혹은 Math.pow()함수를 사용해도 된다
```js
console.log(Math.pow(2, 3 ** 2)); // 512
console.log(Math.pow(Math.pow(2, 3), 2)); // 64
```

### ||, ?? 연산자
이건 알던 내용이지만 참고용으로 한번 더 정리해보자
|| 연산자는 피연산자 중에서 true로 평가되는 첫번째 값을 반환한다
```js
console.log(null || 0 || "" || "hello" || 42); // "hello"
```
위와 같은 코드가 있을 때 null, 0, ""은 모두 false로 평가된다
따라서 "hello"가 true로 평가되는 첫번째 값이기에 "hello"가 반환된다

?? 연산자는 피연산자 중에서 null 또는 undefined가 아닌 첫번째 값을 반환한다
```js
console.log(null ?? undefined ?? 0 ?? "" ?? "hello" ?? 42); // 0
```
위와 같은 코드가 있을 때 null, undefined는 모두 null 또는 undefined이다
따라서 0이 null 또는 undefined가 아닌 첫번째 값이기에 0이 반환된다

|| 와 ?? 연산자는 비슷해 보이지만 다르다
|| 연산자는 false로 평가되는 값(null, undefined, 0, "", false, NaN)을 건너뛰지만
?? 연산자는 null 또는 undefined인 값만 건너뛴다


### 산술 연산자 궁금중 해결
```js
1+true // 2 
// 비트 상으로 true는 1이기에 1+1=2
1+null // 1 
// null은 숫자형으로 변환시 0이기에 1+0=1
1+undefined // NaN 
// undefined는 숫자형으로 변환시 NaN이기에 1+NaN=NaN
// null은 없다라는 뜻, undefined는 정의되지 않았다라는 뜻
1+[] // 1 
//  []는 빈문자열로 변환되기에 1+""= 문자열 "1"이 된다
1+[1,'ㅁ'] // "11,ㅁ"
// [1,'ㅁ']는 "1,ㅁ"로 변환된다. 따라서 1+"1,ㅁ" = "11,ㅁ"
1+ new Array('a') // "1a"
// new Array도 마찬가지
+'s' // NaN
// 앞에 문자열이 없는 위와 같은 상태라면 +는 산술 연산자가 아닌 부호 연산자가 된다
// 따라서 's'는 숫자형으로 변환시 NaN이기에 결과는 NaN이 된다

``` 

### void 연산자
```js
void expression
```
void는 void(표시된 식)의 평가 결과를 무시하고 항상 undefined를 반환한다
```js
console.log(void 0); // undefined
console.log(void (1 + 2)); // undefined
```
위와 같은 형태로 사용된다
그런데 이것도 지금은 좋지 않다
그래서 이전에는 이렇게 사용했다면
```js
<a href="javascript:void(0)">Click me</a>
```
지금은 이렇게 사용한다
```js
<a href="#" onclick="return false;">Click me</a>
```

```js
d = void(c=a+b);
console.log(a,b,c,d);
// d는 항상 undefined가 된다
// 결과 : 1 3 4 undefined
```

### falsy 값

```js
const arr = [undefined, null,false, 0,NaN,'     ','',[],+[]];
for (let i = 0; i < arr.length; i++) {
    console.log(`Value: ${arr[i]}, Boolean: ${!!arr[i]}`);
}
```
arr을 위의 for문으로 돌리면 arr을 전부 메모리에 올리고 시작한다
메모리에 전부 올린다는것은 사실 좋지는 않다
값을 다 올리지는 않고 메모리에 주소값만 올린다고 생각하면 된다

```js
for(const value of arr) {
    console.log(`Value: ${value}, Boolean: ${!!value}`);
}
```
그런데 이렇게 iterator로 돌리면 next값을 호출하면 그때그때 값을 메모리에 올린다
따라서 메모리를 아주 조금 효율적으로 사용할 수 있다는 점. 기억해두자

아무튼 위의 결과값은 다음과 같다
```shell
undefined Boolean: false
null Boolean: false
false Boolean: false
0 Boolean: false
NaN Boolean: false
      Boolean: true
 Boolean: false
 [] Boolean: true
0 Boolean: false # 이게 골떄림
```
위와 같이 '     ' (공백문자열)은 true로 평가된다
그런데 '' (빈문자열)은 false로 평가된다
이 점 기억해둘것

```js
a=null;
if(a){
    console.log("비권장")
}
if(a!==null){
    console.log("권장")
}
```
당연한 것이지만 위와 같이 사용하는것이 좋다


```js
> Array.prototype.toString = function(){return this.join('');}
[Function (anonymous)]
> arr = [1,2,3]
[ 1, 2, 3 ]
> arr.toString()
'123'
```
위와 같이 Array.prototype.toString을 재정의 할 수 있다

JS는 객체지향언어가 아닌 함수형 언어이기 떄문에
함수형 언어에서는 상속을 prototype 체인으로 구현한다
prototype 체인은 나중에 따로 다뤄보자


### . 연산자
```js
> obj={id:1, name:'Hong'}
{ id: 1, name: 'Hong' }
> obj.id
1
> k='id'
'id'
> obj.k
undefined
> obj[k]
1
```
위와 같이 . 연산자는 리터럴로 속성에 접근할 때 사용한다
변수로 속성에 접근할 때는 대괄호 표기법을 사용한다

그런데 이전에 array도 객체라고 했었다
```js
> arr = [10,20,30]
[ 10, 20, 30 ]
>arr['0']
10
>arr.0
Uncaught SyntaxError: Unexpected number
```
위와 같이 array도 객체이기에 대괄호 표기법으로 속성에 접근할 수 있다
```js
{
    '0': 10,
    '1': 20,
    '2': 30
}
```
이런 형태로 되어 있기 때문이다


### instanceof 연산자
```js
> arr = [1,2,3]
[ 1, 2, 3 ]
> arr instanceof Array
true
> arr instanceof Object
true
> obj = {id:1}
{ id: 1 }
> obj instanceof Object
true
> obj instanceof Array
false
```
위와 같이 instanceof 연산자는 객체가 특정 생성자의 prototype을 상속받았는지 확인할 때 사용한다
따라서 array는 Object를 상속받았기에 arr instanceof Object는 true가 된다
하지만 obj는 Array를 상속받지 않았기에 obj instanceof Array는 false가 된다

### rest 연산자
```js
function func(a,b,...c) {
    console.log(a,b,c, ...c); 
}
func(1,2,3,4,5);
// 출력 : 1 2 [3,4,5] 3 4 5
```
... 연산자는 함수의 매개변수에서 사용되며 나머지 인자들을 배열로 묶어준다
이건 rest 연산자라고 하는데, 위의 `console.log()`에서의 `...c` 부분은 spread 연산자이다 성격이 다르니 주의하자