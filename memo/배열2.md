

```js
arr = [1,3,2,5,4,10];
a1 = arr.slice();
> a1 === arr
false
```
a1에 arr을 읽은 후 새로운 배열을 만들어서 할당하기 때문에 a1과 arr은 다른 배열이다
그래서 `a1 = [...arr]`과 동일하다



### 유사배열 객체
```js
let arr = [1,2,3,4,5];
for( let i=0; i<arr.length; i++ ) {
  console.log(i);
  if(i>1) break;
}
// 0
// 1
// 2
arr.forEach( (value, index) => {
  console.log(index);
  if(index>1) return;
});
// 0
// 1
// 2
// 3
// 4
let str= 'abcde';
str.forEach( (value, index) => {
  console.log(index);
});
// TypeError: str.forEach is not a function
```

- 유사배열 객체는 forEach 메서드를 사용할 수 없다
- 이를 제외한 Array 메서드는 사용 가능하다
  - 예) slice, splice, map, filter, reduce 등
  - 예외) forEach, reduceRight, some, every, find, findIndex 등
  - 이유 : 이 메서드들은 내부적으로 this를 사용하기 때문이다. 
- 유사배열 객체에 Array 메서드를 사용하려면 `Array.prototype.메서드명.call(유사배열객체, ...)` 형태로 사용해야 한다
  - 예) `Array.prototype.forEach.call(str, (value, index) => { ... })`
- 또는 `Array.from(유사배열객체).메서드명(...)` 형태로 사용 가능하다
  - 예) `Array.from(str).forEach( (value, index) => { ... })`
- 또는 `[...유사배열객체].메서드명(...)` 형태로 사용 가능하다
  - 예) `[...str].forEach( (value, index) => { ... })`



### `Array.prototype.sort()`의 정렬 알고리즘

-   **표준의 정의**: ECMAScript 명세는 `sort()`가 사용할 특정 알고리즘(예: 퀵 정렬)을 **강제하지 않는다.** 단, ES2019부터 **안정 정렬(Stable Sort)**임은 보장된다.
    -   **안정 정렬**: 정렬할 값이 같은 여러 요소가 있을 때, 이 요소들의 원래 순서가 정렬 후에도 그대로 유지되는 방식.
    -   **기본 정렬**: 비교 함수가 없으면 모든 요소를 문자열로 변환하여 UTF-16 코드 유닛 순서로 정렬한다. (`[1, 10, 2]`가 `[1, 10, 2]`로 정렬되는 이유)

-   **엔진별 구현**:
    -   **V8 (Chrome, Node.js)**: **팀소트(Timsort)**를 사용한다.
    -   **SpiderMonkey (Firefox)**: **병합 정렬(Merge Sort)** 기반의 알고리즘을 사용한다.

### 팀소트(Timsort)란?

-   **개념**: **삽입 정렬(Insertion Sort)**과 **병합 정렬(Merge Sort)**의 장점을 결합한 하이브리드 정렬 알고리즘.
-   **동작 방식**:
    1.  배열을 'run'이라는 작은 단위로 나눈다.
    2.  이미 정렬된 작은 'run'들은 **삽입 정렬**로 매우 빠르게 처리한다.
    3.  정렬된 'run'들을 **병합 정렬** 방식으로 효율적으로 병합하여 전체를 정렬한다.
-   **특징**:
    -   **시간 복잡도**: 평균과 최악 모두 **O(n log n)**.
    -   **효율성**: 실제 데이터는 부분적으로 정렬된 경우가 많다는 점을 활용하여 성능이 매우 좋다.

---

### 보충: 삽입 정렬과 병합 정렬

#### 1. 삽입 정렬 (Insertion Sort)

-   **개념**: 손에 든 카드를 정렬하는 방식과 유사하다. 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 부분의 첫 번째 요소를 가져와 정렬된 부분의 올바른 위치에 '삽입'하는 것을 반복한다.
-   **동작 방식**:
    1.  두 번째 요소부터 시작하여 '키(key)'로 선택한다.
    2.  키를 정렬된 왼쪽 부분의 요소들과 비교하여, 키보다 큰 요소들을 오른쪽으로 한 칸씩 이동시킨다.
    3.  키보다 작거나 같은 요소를 만나면, 그 요소 바로 뒤에 키를 삽입한다.
-   **시간 복잡도**:
    -   최선: **O(n)** (이미 정렬된 경우)
    -   평균/최악: **O(n²)**
-   **장점**: 작은 데이터셋이나 거의 정렬된 데이터셋에 매우 효율적이다. 알고리즘이 간단하고, 추가 메모리(O(1))를 거의 사용하지 않는다.

#### 2. 병합 정렬 (Merge Sort)

-   **개념**: "분할 정복(Divide and Conquer)" 전략을 사용하는 대표적인 알고리즘.
-   **동작 방식**:
    1.  **분할(Divide)**: 배열의 크기가 1이 될 때까지 재귀적으로 계속 반으로 나눈다.
    2.  **정복(Conquer/Merge)**: 나눠진 작은 배열들을 두 개씩 짝지어, 정렬하면서 다시 하나의 배열로 '병합'한다. 이 과정을 모든 배열이 다시 하나로 합쳐질 때까지 반복한다.
-   **시간 복잡도**:
    -   최선/평균/최악: 모두 **O(n log n)**으로 일관된 성능을 보인다.
-   **장점**: 데이터의 분포와 상관없이 항상 O(n log n)의 성능을 보장한다. 안정 정렬이 가능하다.
-   **단점**: 정렬 과정에서 임시 배열을 위한 추가 메모리(O(n))가 필요하다.