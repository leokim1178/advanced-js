

### property
- property 자체도 하나의 객체다
- 예를 들어
```javascript
const person = {
  name: 'John',
  age: 30,
};
```
- person 객체는 name과 age라는 두 개의 property를 가지고 있다
- 각 property는 key-value 쌍으로 구성되어 있다
- {key:'name', value:'John'}, {key:'age', value:30}와 같다

### property 표현 규칙
```javascript
const user = {
  '': 1,        
  ' ': 1,       // 'id': 1, '0y': 2 모두 OK!
  123: 1,       // user[123], user['123'] OK, but user.123 is SyntaxError!!
  12345n: 2,    // user[12345], user[12345n], user['12345'] OK, but user['12345n'] is undefined!
  true: 1,      // OK  user[true]  user.true
  id: 2,          
  [`name`]: 'Hong',  // But, `name`: 'Hong'은 SyntaxError: Unexpected template string!
  [Symbol()]: 'Hong',   // OK But, Symbol(): 'Hong'은 SyntaxError: Unexpected token ':'
  [`${new Date()}`]: 365,    // OK! 'Sun Jul …': 365
  'my-friends': ['Han', 'Kim'],
  getInfo: () => `${this.id}-${this.name}`,       // OK! But, this is not user! // 함수 리터럴을 가진 property
  getInfo() { return `${this.id}-${this.name}`; }, // OK! getInfo의 최종 <f.o> // 함수 object, method
} 
```

- property key는 문자열 또는 심볼이어야 한다
- 숫자형 키는 내부적으로 문자열로 변환된다
- 공백 문자나 빈 문자열도 유효한 키로 사용할 수 있다
- 템플릿 리터럴이나 계산된 속성 이름도 사용할 수 있다
- 함수 리터럴을 가진 property와 method도 정의할 수 있다 

key들을 출력해보면 다음과 같다
```js
const keys = Object.keys(user);
console.log(keys); 

```
결과값: 
```js
[
  '123',
  '12345',
  '',
  ' ',
  'true',
  'id',
  'name',
  'Sun Nov 30 2025 23:14:33 GMT+0900 (Korean Standard Time)',
  'my-friends',
  'getInfo'
]
```
123이 문자열로, 12345n이 12345로 변환된 것을 볼 수 있다
n이 붙은 빅인트형 키는 문자열로 변환될 때 n이 제거된다
(12345n).toString()으로 변환되었다고 보면 된다
그 외에 true도 'true'로 변환된 것을 볼 수 있다
Symbol 키는 Object.keys() 메서드로 출력되지 않는다

Symbol 키를 보려면 Reflect.ownKeys() 메서드를 사용해야 한다
```js
const allKeys = Reflect.ownKeys(user);
console.log(allKeys);
```
결과값:
```js
[
  '123',
  '12345',
  '',
  ' ',
  'true',
  'id',
  'name',
  'Sun Nov 30 2025 23:20:52 GMT+0900 (Korean Standard Time)',
  'my-friends',
  'getInfo',
  Symbol()
]
```

property key 유무 판별
```js
console.log('id' in user);          // true
conosole.log(user.hasOwnProperty('id')); // true
``` 
- in 연산자와 hasOwnProperty() 메서드를 사용하여 객체에 특정 property key가 존재하는지 확인할 수 있다
- 두 방법 모두 해당 key가 객체에 존재하면 true를 반환하고, 그렇지 않으면 false를 반환한다
- in 연산자는 객체의 prototype chain에 있는 property도 검사하지만, hasOwnProperty() 메서드는 객체 자체에 있는 property만 검사한다
- 따라서, prototype chain에 있는 property를 포함하여 검사하려면 in 연산자를 사용하고, 객체 자체에 있는 property만 검사하려면 hasOwnProperty() 메서드를 사용하는 것이 좋다
- 타입스크립트에서는 in 연산자를 사용한 방법은 타입 가드로도 활용할 수 있기 때문에 in 연산자가 더 쓸만하다
- 예를 들어, 다음과 같이 사용할 수 있다
```ts
interface Cat {
  meow: () => void;
} 
interface Dog {
  bark: () => void;
}
function makeSound(animal: Cat | Dog) {
  if ('meow' in animal) {
    animal.meow(); // animal이 Cat 타입임이 보장됨
  } else {
    animal.bark(); // animal이 Dog 타입임이 보장됨
  }
} 
```

property descriptor
- 자바스크립트 객체의 property는 단순한 key-value 쌍 이상의 정보를 포함할 수 있다
- property descriptor는 객체의 property에 대한 추가적인 메타데이터를 제공한다
- property descriptor는 다음과 같은 속성들을 포함할 수 있다
  - value: property의 값
  - writable: property의 값이 변경 가능한지 여부를 나타내는 불리언 값
  - enumerable: property가 열거 가능한지 여부를 나타내는 불리언 값
  - configurable: property의 설정이 변경 가능한지 여부를 나타내는 불리언 값

```js
const user = {
  '': 1,        
  ' ': 1,       // 'id': 1, '0y': 2 모두 OK!
  123: 1,       // user[123], user['123'] OK, but user.123 is SyntaxError!!
  12345n: 2,    // user[12345], user[12345n], user['12345'] OK, but user['12345n'] is undefined!
  true: 1,      // OK  user[true]  user.true
  id: 2,          
  [`name`]: 'Hong',  // But, `name`: 'Hong'은 SyntaxError: Unexpected template string!
  [Symbol()]: 'Hong',   // OK But, Symbol(): 'Hong'은 SyntaxError: Unexpected token ':'
  [`${new Date()}`]: 365,    // OK! 'Sun Jul …': 365
  'my-friends': ['Han', 'Kim'],
  getInfo: () => `${this.id}-${this.name}`,       // OK! But, this is not user!
  getInfo() { return `${this.id}-${this.name}`; }, // OK! getInfo의 최종 <f.o>
} 

const propertyDescription = Object.getOwnPropertyDescriptor(user, 'id');
console.log(propertyDescription);
// const propertyDescriptions = Object.getOwnPropertyDescriptors(user);

user.id = 3;
Object.defineProperty(user, 'id', {
    writable: false,
})
user.id=4; // 무시됨
const propertyDescription2 = Object.getOwnPropertyDescriptor(user, 'id');
console.log(propertyDescription2);
```
위와 같이 Object.getOwnPropertyDescriptor() 메서드를 사용하여 특정 property의 descriptor를 가져올 수 있다
또한, Object.defineProperty() 메서드를 사용하여 property descriptor를 수정할 수도 있다
위에서 id property의 writable 속성을 false로 설정하여 값을 변경할 수 없도록 만들었다
그런 후에는 값이 바뀌지 않는 것을 확인할 수 있다

그럼 enumerable와 configurable 속성도 바꿔보자
```js
Object.defineProperty(user, 'id', {
    enumerable: false,
    configurable: false,
});
for (const key in user) {
    console.log(key);  // id는 출력 안됨
}
console.log(Object.getOwnPropertyNames(user)); // id는 출력됨
Object.defineProperty(user, 'id', {
    writable: true,
}); // TypeError: Cannot redefine property: id  
// configurable이 false이기 때문에 오류 발생
```
- enumerable 속성을 false로 설정하면 for...in 루프에서 해당 property가 열거되지 않는다
- 그러나 Object.getOwnPropertyNames() 메서드를 사용하면 여전히 해당 property를 가져올 수 있다
- configurable 속성을 false로 설정하면 해당 property의 descriptor를 더 이상 변경할 수 없다
- 따라서, writable 속성을 다시 true로 변경하려고 하면 TypeError가 발생한다


Object.assign() 메서드와 property descriptor
```js
const user = {
  id: 1,
  name: 'Hong',
};
Object.assign({x:100}, user);
```
user와는 다른 새로운 객체가 만들어지고, 그 객체에 x:100, id:1, name:'Hong'이 복사된다

```js
Object.assign(user,{
    getName() {
        return this.name;
    }
})
console.log(user.getName()); // 'Hong'
```
이렇게 user에 새로운 method를 추가할 수도 있다
이를 mix-in 패턴이라고 한다
Object.assign() 메서드는 이렇게 객체를 병합하거나 확장하는 데 유용하게 사용될 수 있다
예를 들어 다음과 같이 copy를 만들 수도 있는데 이는 원본과 다른 새로운 객체가 된다
```js
const copy = Object.assign({}, user);
console.log(copy===user); // false
```
따라서 원본을 오염시키지 않고도 객체를 확장하거나 수정할 수 있다

### 주의할점
Object.create() 메서드를 사용하여 객체를 생성할 때
```js
obj = Object.create({id:1, f:function() {}});
console.log(obj);// {}
obj.__proto_; // {id:1, f:function() {}}
```
- obj 객체는 프로토타입으로 {id:1, f:function() {}}를 가진다
- 따라서 obj 객체 자체에는 id나 f라는 property가 없고, 프로토타입 체인을 통해 접근할 수 있다
- 이 경우 Object.keys(obj)나 Object.getOwnPropertyNames(obj)를 사용하면 빈 배열이 반환된다
- obj 객체 자체에는 property가 없기 때문이다
- 프로토타입 체인에 있는 property를 포함하여 모든 property를 가져오려면 Reflect.ownKeys() 메서드를 사용해야 한다
- 그러나 이 경우에도 obj 객체 자체에는 property가 없기 때문에 빈 배열이 반환된다
- 프로토타입 체인에 있는 property를 포함하여 모든 property를 가져오려면 for...in 루프를 사용해야 한다