


```js
for(var i=0; i<5; i++){
    setTimeout(()=>console.log(i), 1000);
}
// 결과값
// 5 
// 5
// 5
// 5
// 5
for(let i=0; i<5; i++){
    setTimeout(()=>console.log(i), 1000);
}
// 결과값
// 0
// 1
// 2
// 3
// 4
```

첫번째 for문에서는 var 키워드로 인해 i 가 함수 스코프를 가지게 되어 모든 콜백 함수가 호출될 때 동일한 i 값을 참조하게 된다

두번째 for문에서는 let 키워드로 인해 i 가 블록 스코프를 가지게 되어 각각의 콜백 함수가 호출될 때의 i 값을 기억하게 된다

따라서 첫번째 for문에서는 모두 5가 출력되고, 두번째 for문에서는 0부터 4까지의 값이 출력된다


### switch문에서 주의할점
```js

function switchTest(value){
    switch(value){
        case 1:
            const y= value + 1;
                return "one"
        case 2:
            const y= value + 2; // 이미 선언된 y 변수 때문에 에러 발생
                return "two"
        case 3:
                return "three"
        default:
                return "default"
    }
}
```
위 함수에서 const를 사용해 case1에 a를 선언했다고 가정해보자
이렇게 했을때, switch문은 하나의 블록으로 인식되기 때문에 case1에서 선언된 a가 case2, case3에서도 유효하게 되는 호이스팅이 발생한다
따라서 case2, case3에서 a를 다시 선언하려고 하면 이미 선언된 a 때문에 reference error가 발생하게 된다
case scope는 lexical scope가 아니기 때문에 이런 현상이 발생하는 것이다
이를 방지하기 위해서는 아래와 같이 case문마다 중괄호({})로 블록을 만들어 주어야 한다
```js
function switchTest(value){
    switch(value){
        case 1: {
            const y= value + 1;
                return "one"
        }
        case 2: {
            const y= value + 2; // 이제 에러가 발생하지 않음
                return "two"
        }
        case 3: {
                return "three"
        }
        default: {
                return "default"
        }
    }
}
```

### for문에서의 주의점
```js
for(let i=0; i<arr.length; i++){
    // do something with item
}
```
java와 같은 컴파일 언어에서는 arr.length와 같이 for문 내에서 length를 사용하는것은 금기시된다
length를 매번 참조할때마다 개수를 세야하기 때문이다
하지만 javascript의 array의 경우 객체 내부에 length 프로퍼티가 존재하기 때문에 length를 참조할때마다 개수를 세지 않는다
따라서 javascript에서는 위와 같이 for문에서 length를 사용하는것이 성능에 큰 영향을 미치지 않는다

