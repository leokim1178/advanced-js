js는 함수형 인터프리터 언어다
함수 자체가 객체가 되고 함수 자체가 식별자가 되기 때문에 인터프리터로서 많이 사용된다


함수는 statement의 묶음이다
class는 함수와 데이터를 묶는 역할이다
그렇다면 함수는 데이터를 못 갖느냐
그렇지는 않다
함수형 언어에서는 그래서 함수와 class는 거의 동급이다
함수형 언어에서는 함수를 1급 객체로 다룬다

1급 객체, 2급 객체 등 객체의 등급에 대해 짚고 넘어가자


### 1급 객체 (First-Class Object / First-Class Citizen)

컴퓨터 프로그래밍에서 **1급 객체**란 다른 객체들과 동등한 권리를 갖는 객체를 의미한다. 특정 언어의 어떤 요소가 1급 객체라면, 그것은 일반적인 값(예: 숫자, 문자열)처럼 자유롭게 다룰 수 있다.

핵심 조건은 다음과 같다.
1.  **변수나 자료구조(객체, 배열 등)에 할당할 수 있다.**
2.  **함수의 인자(argument)로 전달할 수 있다.**
3.  **함수의 반환값(return value)으로 사용할 수 있다.**

**JavaScript에서 함수는 대표적인 1급 객체다.**

```javascript
// 1. 변수에 할당할 수 있다.
const sayHello = function() {
  console.log('Hello!');
};

// 2. 함수의 인자로 전달할 수 있다.
function greet(fn) {
  fn();
}
greet(sayHello); // 'Hello!' 출력

// 3. 함수의 반환값으로 사용할 수 있다.
function createGreeter() {
  return function() {
    console.log('Hi there!');
  };
}
const greeter = createGreeter();
greeter(); // 'Hi there!' 출력
```

JavaScript에서 함수는 값처럼 자유롭게 다룰 수 있기 때문에, 고차 함수(Higher-Order Function)나 클로저 같은 강력한 프로그래밍 패턴이 가능하다.

### 2급 객체 (Second-Class Object)

2급 객체는 1급 객체와 달리 사용에 제약이 있는 객체를 말한다. 예를 들어, 아래 조건 중 하나 이상을 만족하지 못하는 경우다.
-   변수에 할당할 수 없다.
-   함수의 인자로 전달할 수 없다.
-   함수의 반환값으로 사용할 수 없다.

많은 언어에서 함수는 2급 객체로 취급된다. 예를 들어, C언어에서는 함수를 직접 변수에 담거나 전달하는 것이 아니라 **함수 포인터**를 사용해야 하므로, JavaScript의 함수처럼 완전한 1급 객체라고 보기는 어렵다.

### 3급 객체 (Third-Class Object)

2급 객체보다도 더 제약이 심한 경우를 말한다. C언어의 `goto` 문에서 사용되는 레이블(label)처럼, 값으로 다룰 수 있는 어떠한 방법도 제공되지 않는 경우가 해당될 수 있다.


---
함수는 생성자 함수와 일반 함수로 구분된다

### 생성자 함수 vs 일반 함수

JavaScript에서 함수는 호출 방식에 따라 일반 함수로 동작할 수도, 객체를 생성하는 생성자 함수로 동작할 수도 있다.

#### 일반 함수 (Regular Function)

-   단순히 코드를 실행하고 값을 반환하는 데 사용된다.
-   `return` 문이 없으면 `undefined`를 반환한다.
-   `this`는 호출 방식에 따라 결정된다 (전역 객체, `undefined` 등).

```javascript
function add(a, b) {
  return a + b;
}

const result = add(3, 5); // result는 8
// const instance = new add(3, 5); // 의도하지 않은 사용. add {} 객체가 반환됨
```

#### 생성자 함수 (Constructor Function)

-   `new` 키워드와 함께 호출되어 새로운 객체(인스턴스)를 생성한다.
-   함수 이름의 첫 글자는 대문자로 작성하는 것이 관례다 (PascalCase).
-   `this`는 새로 생성된 인스턴스를 가리킨다.
-   별도의 `return` 문이 없으면 생성된 인스턴스(`this`)가 암묵적으로 반환된다.

```javascript
function Person(name, age) {
  // this는 새로 생성될 인스턴스
  this.name = name;
  this.age = age;
  this.greet = function() {
    console.log(`Hello, my name is ${this.name}`);
  };
}

// 'new'와 함께 호출
const person1 = new Person('Kim', 30);
console.log(person1.name); // 'Kim'
person1.greet(); // 'Hello, my name is Kim'

// 'new' 없이 호출 (일반 함수로 동작)
const person2 = Person('Lee', 25);
console.log(person2); // undefined (return 값이 없으므로)
// console.log(window.name); // 'Lee' (일반 함수로 호출되어 this가 전역 객체를 가리킴)
```

#### 주요 차이점 요약

| 구분 | 일반 함수 | 생성자 함수 |
| --- | --- | --- |
| **호출** | `myFunction()` | `new MyFunction()` |
| **네이밍** | `camelCase` | `PascalCase` |
| **`this`** | 전역 객체 (`window`) 또는 `undefined` (strict mode) | 새로 생성된 인스턴스 |
| **반환값**| 명시적 `return` 값 또는 `undefined` | `this` (새 인스턴스)가 암묵적으로 반환 |

```js
function Dog(name) {
    // 보이지는 않지만 내부적으로 constructor가 있다
    constructor(){
        super.constructor(); 
    } // 이런 코드가 생략되어 있다고 보면 된다
  this.name = name;
}
```

```js
function hello(){
    return 'Hello';
}
const fn = hello, obj = {fn:hello}, a = [hello];
// 위와 같이 함수를 변수에 할당할 수 있으며
fn();
obj.fn();
a[0]();
// 이렇게 실행할수 있다
```

함수는 기본적으로 name,length 프로퍼티를 가진다
name은 함수의 이름, length는 매개변수의 개수다


js는 함수 overload를 지원하지 않는다
같은 이름의 함수를 여러개 만들 수 없다
마지막에 선언된 함수가 이전에 선언된 함수를 덮어쓴다


### 즉시 호출 함수
즉시 호출 함수(IIFE, Immediately Invoked Function Expression)는 정의되자마자 즉시 실행되는 함수다. 주로 변수의 유효 범위를 제한하거나 초기화 작업을 수행할 때 사용된다.

```javascript
(
    // 앞에 async를 붙일수도 있다 비동기 처리를 위해
    function() {
  // 이 안의 변수와 함수는 외부에서 접근할 수 없다
  const privateVar = 'I am private';
  function privateFunction() {
    console.log(privateVar);
  }
})();
// privateVar와 privateFunction은 외부에서 접근 불가
```

일반 블록 실행의 경우
```js
{
    const foo = 'foo';
    let bar = 'bar';
}
```

둘의 차이는
일반적 실행의 경우 블록 environment 레코드가 생기고
콜스택에 올라가지 않는다
즉시 실행 함수의 경우 함수 environment 레코드가 생긴다
이러면 콜스택에 올라간다
