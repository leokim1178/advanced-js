# CommonJS vs ES Module

## 개요

JavaScript 모듈 시스템의 두 가지 주요 방식을 비교한다.

## CommonJS (CJS)

### 특징

- **Node.js**의 기본 모듈 시스템
- **동기적(Synchronous)** 로딩
- **런타임**에 모듈을 로드
- `require()`와 `module.exports` 사용
- 2011년에 제안되어 널리 사용됨

### 문법

```javascript
// 내보내기 (export)
// math.js
function add(a, b) {
  return a + b;
}

function subtract(a, b) {
  return a - b;
}

module.exports = {
  add,
  subtract,
};

// 또는
exports.add = add;
exports.subtract = subtract;

// 가져오기 (import)
// main.js
const math = require("./math");
console.log(math.add(1, 2)); // 3

// 구조분해할당
const { add, subtract } = require("./math");
console.log(add(1, 2)); // 3
```

### 장점

- Node.js 환경에서 안정적
- 동기적 로딩으로 간단한 사용
- 조건부 `require()` 가능

### 단점

- 브라우저에서 기본 지원 안 됨
- 정적 분석 어려움 (트리 쉐이킹 불가)
- 비동기 로딩 불가

---

## ES Module (ESM)

### 특징

- **ECMAScript 표준** 모듈 시스템 (from ES6/ES2015)
- **비동기적(Asynchronous)** 로딩
- **컴파일 타임**에 모듈 구조 분석
- `import`와 `export` 사용
- **정적 구조**: 최상위 레벨에서만 import/export 가능

### 문법

```javascript
// 내보내기 (export)
// math.js

// Named export
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

// 또는 한번에
export { add, subtract };

// Default export
export default function multiply(a, b) {
  return a * b;
}

// 가져오기 (import)
// main.js

// Named import
import { add, subtract } from "./math.js";
console.log(add(1, 2)); // 3

// Default import
import multiply from "./math.js";
console.log(multiply(2, 3)); // 6

// 모두 가져오기
import * as math from "./math.js";
console.log(math.add(1, 2)); // 3

// 별칭(alias) 사용
import { add as sum } from "./math.js";
console.log(sum(1, 2)); // 3
```

### 장점

- 브라우저와 Node.js 모두 지원 (표준)
- **트리 쉐이킹(Tree Shaking)** 가능 (사용하지 않는 코드 제거)
- 정적 분석으로 최적화 가능
- 비동기 로딩으로 성능 향상
- 모듈 스코프를 가지며 애플리케이션과 독립적으로 자체 컴파일 단위를 형성

### 단점

- Node.js에서 사용하려면 설정 필요 (`"type": "module"` in package.json)
- 조건부 import 불가 (동적 import는 가능하지만 다른 문법)
- 구버전 브라우저 지원 안 됨

---

## 주요 차이점 비교

| 특징            | CommonJS                          | ES Module                             |
| --------------- | --------------------------------- | ------------------------------------- |
| **문법**        | `require()`, `module.exports`     | `import`, `export`                    |
| **로딩 방식**   | 동기적 (Synchronous)              | 비동기적 (Asynchronous)               |
| **로딩 시점**   | 런타임 (Runtime)                  | 컴파일 타임 (Compile time)            |
| **구조**        | 동적 (Dynamic)                    | 정적 (Static)                         |
| **환경**        | Node.js 기본                      | 브라우저 + Node.js (표준)             |
| **트리 쉐이킹** | 불가능                            | 가능                                  |
| **조건부 로드** | 가능 (`if` 문 안에서 `require()`) | 불가능 (동적 import는 가능)           |
| **this**        | `module.exports` 객체             | `undefined`                           |
| **파일 확장자** | `.js` (기본)                      | `.mjs` 또는 `.js` (package.json 설정) |

---

## Node.js에서 ES Module 사용하기

### 방법 1: package.json 설정

```json
{
  "type": "module"
}
```

### 방법 2: .mjs 확장자 사용

```javascript
// math.mjs
export function add(a, b) {
  return a + b;
}

// main.mjs
import { add } from "./math.mjs";
```

---

## 동적 Import (Dynamic Import)

ES Module에서도 런타임에 모듈을 로드할 수 있다 (Promise 기반).

```javascript
// 조건부 로딩
if (condition) {
  const module = await import("./module.js");
  module.doSomething();
}

// 또는
import("./module.js")
  .then((module) => {
    module.doSomething();
  })
  .catch((err) => {
    console.error("모듈 로드 실패:", err);
  });
```

---

## 실무 권장사항

### CommonJS 사용

- Node.js 서버 애플리케이션 (기존 코드베이스)
- npm 패키지 (넓은 호환성 필요)

### ES Module 사용

- 모던 웹 애플리케이션 (React, Vue, etc.)
- 번들러 사용 (Webpack, Vite, Rollup)
- 트리 쉐이킹이 필요한 경우
- 신규 프로젝트

### 혼용 (Dual Package)

많은 npm 패키지들이 두 방식을 모두 지원한다.

```json
{
  "main": "./dist/index.cjs", // CommonJS entry
  "module": "./dist/index.mjs", // ES Module entry
  "exports": {
    "import": "./dist/index.mjs",
    "require": "./dist/index.cjs"
  }
}
```

---

## 마이그레이션 팁

CommonJS → ES Module 전환 시:

1. `package.json`에 `"type": "module"` 추가
2. `require()` → `import` 변경
3. `module.exports` → `export` 변경
4. `__dirname`, `__filename` 대체 필요

   ```javascript
   // ESM에서
   import { fileURLToPath } from "url";
   import { dirname } from "path";

   const __filename = fileURLToPath(import.meta.url);
   const __dirname = dirname(__filename);
   ```

5. 확장자 명시 필요 (`.js` 포함)
   ```javascript
   import { add } from "./math.js"; // .js 필수
   ```

---

## 정리

- **ES Module**이 표준이며 미래 지향적
- **CommonJS**는 Node.js 생태계에서 여전히 널리 사용
- 신규 프로젝트는 ES Module 권장
- 기존 프로젝트는 점진적 마이그레이션 고려

## Webpack

- ESM으로 코딩을 하고 배포를 CommonJS로 해야한다면 번들링을 해야한다

## defer

- html과 css dom이 로드되서 다 메모리에 올라가고 난 후 js를 컴파일 하고 실행시키라고 하는 것
- module은 무조건 defer 속성이므로 구문분석을 지연시키지 않는다
- 조금 늦게 될수는 있다

```
<script src="mod.js" defer></script>   // cf. defer는 HTML 구문분석 완료 후 실행!
<script src="mod.js"></script>         // cf. nomodule (<script nomodule src…)
<script src="mod.js" async></script>   // 가능한 빨리 (HTML 구문분석과 병행)
                    <script> (구문분석) → (스크립트 처리) → [실행]  → (구문분석)
              <script defer> (구문분석) → (구문분석 & 스크립트 처리) → (DOM생성) → [실행]
              <script async> (구문분석) → (구문분석 & 스크립트 처리) → [실행] → (DOM생성)
      <script type="module"> (구문분석) → (구문분석 & 스크립트 처리) → [실행]
<script type="module" async> (구문분석) → (구문분석 & 스크립트 처리) → [실행] → (구문분석)
```

[[ImportEntries]] 와 [[ExportEntries]] 를 전역에서 관리한다

## 모듈 로더의 동작 원리
