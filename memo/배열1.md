# JavaScript 자료구조별 시간 복잡도 (Big O) 및 사용법 정리

## 1. 배열 (Array)

### 시간 복잡도

-   **인덱스 접근 (`arr[i]`)**: **O(1)**
    -   배열의 길이에 상관없이 특정 인덱스의 요소에 접근하는 속도는 거의 일정하다. JavaScript 엔진이 메모리 주소를 효율적으로 계산하기 때문이다.
-   **값 검색 (`arr.indexOf(value)`, `arr.find(...)`)**: **O(n)**
    -   특정 값을 찾으려면 배열의 모든 요소를 순차적으로 확인해야 할 수 있으므로, 배열 길이에 비례하여 시간이 걸린다.
-   **요소 추가/삭제**:
    -   `push` (끝에 추가): **O(1)** (평균)
    -   `pop` (끝에서 제거): **O(1)**
    -   `unshift` (앞에 추가): **O(n)** (모든 요소의 인덱스를 뒤로 밀어야 함)
    -   `shift` (앞에서 제거): **O(n)** (모든 요소의 인덱스를 앞으로 당겨야 함)

### `map`, `filter`, `reduce` 등 배열 메서드

-   **시간 복잡도**: 이 메서드들은 내부적으로 배열의 모든 요소를 순회하므로 **O(n)** 이다.
-   **등장 배경**: 시간 복잡도 개선이 아니라, `for`문보다 코드를 더 **선언적이고 가독성 높게** 작성하고, 부수 효과를 줄이는 등 함수형 프로그래밍 스타일을 지원하기 위해 도입되었다.

## 2. Map, Set

-   **주요 연산 (추가, 삭제, 검색)**: **O(1)** (평균)
    -   내부적으로 해시 테이블 구조를 사용하므로, 데이터의 양과 상관없이 매우 빠른 속도로 요소를 추가(`set`, `add`), 삭제(`delete`), 검색(`get`, `has`)할 수 있다. (엄밀히는 해시 충돌 시 최악의 경우 O(n)이 될 수 있다.)

## 3. 어떤 자료구조를 선택해야 할까?

"배열보다 Map/Set이 좋다"는 것은 잘못된 생각이다. **상황에 따라 적절한 자료구조를 선택해야 한다.**

-   **Array**: **순서가 있는 데이터 목록**이 필요할 때.
-   **Map**: **Key-Value 쌍**으로 데이터를 저장하고, Key로 빠르게 값을 찾아야 할 때.
-   **Set**: **중복 없는 값의 집합**을 다루고, 특정 값의 존재 여부를 빠르게 확인해야 할 때.

## 4. 공간 복잡도 (메모리 사용량)

-   **`map`, `filter`**: 원본 배열을 바탕으로 **새로운 배열을 생성**하여 반환하므로, 추가적인 메모리를 사용한다. (공간 복잡도: **O(n)**)
-   **`forEach`, `for...of`**: 새로운 배열을 생성하지 않고 순회만 하므로, 추가적인 메모리 사용량이 거의 없다. (공간 복잡도: **O(1)**)
    -   그런데 forEach의 경우 다음과 같은 단점이 있다
```js
arr = [10,20,30,40,50]
arr.forEach((a,i)=>{
    console.log(a);
    if(a>20) return; // forEach에서는 이 return이 아무 의미가 없다
}) // 출력값 : 10 20 30 40 50
for(const a of arr){
    console.log(a);
    if(a>20) break; // for...of에서는 이 break가 루프를 종료시킨다
} // 출력값 : 10 20
```
기대했던 결과가 나오지 않는다
왜 이럴까?

### 왜 `forEach`에서는 `return`이 동작하지 않을까?

핵심적인 이유는 **`forEach`는 단순한 반복문이 아니라, 콜백 함수(callback function)를 인자로 받는 고차 함수(higher-order function)**이기 때문이다.

```javascript
arr.forEach((a, i) => {
  // 이 부분은 별도의 함수입니다.
  console.log(a);
  if (a > 20) return; // 이 return은 콜백 함수를 종료시킬 뿐, forEach 자체를 멈추지 못합니다.
});
```

1.  `forEach`는 배열의 각 요소를 순회하면서 우리가 전달한 **콜백 함수를 매번 새로 호출**이다.
2.  콜백 함수 안의 `return` 문은 `forEach`라는 반복 흐름 전체를 멈추는 것이 아니라, **그 순간 호출된 콜백 함수 하나만을 종료**시킨다.
3.  따라서 `a`가 30이 되어 `return`이 실행되더라도, 이는 "30에 대한 콜백 함수"만 종료시킨 것이고, `forEach`는 멈추지 않고 다음 요소인 40을 가지고 또 새로운 콜백 함수를 호출한다.

마치 `for`문으로 아래와 같이 코드를 짠 것과 같다.

```javascript
function doSomething(a) {
  console.log(a);
  if (a > 20) return; // 이 함수만 종료됨
}

for (const a of arr) {
  doSomething(a); // for문은 계속 실행됨
}
```

### `for...of`는 왜 `break`가 동작할까?

반면에 `for...of`는 **언어 자체에 내장된 반복문(loop statement)**이다. `break`와 `continue`는 바로 이런 반복문을 제어하기 위해 만들어진 키워드다. 따라서 `for...of` 블록 안에서 `break`를 만나면, JavaScript 엔진은 즉시 해당 반복문 전체를 탈출한다.

### 결론

-   **`forEach`**: 중간에 멈출 수 없다. 배열의 모든 요소를 순회해야 할 때 사용한다.
-   **`for...of`**: `break`, `continue`를 사용하여 반복을 자유롭게 제어할 수 있다. 중간에 반복을 멈춰야 할 경우 사용한다.

만약 배열 메서드 스타일을 유지하면서 반복을 중간에 멈추고 싶다면, `some`이나 `every` 같은 메서드를 활용할 수 있다.

```javascript
// 20보다 큰 요소를 만나면 순회를 멈춘다.
arr.some((a) => {
  console.log(a);
  return a > 20;
});
// 출력: 10 20 30
```


프론트에서는 가급적 순수함수를 사용해야 한다


```js
Array(10); // 1번
new Array(10); // 2번
```
1번과 2번은 동일하다
실행하면 아래와 같이 나온다
`[ <10 empty items> ]`
여기서 empty는 undefined나 null이 아닌 진짜 비어있는 상태이다
js엔진 입장에서는 메모리에 공간만 할당해놓고 값을 넣지 않은 상태이다
따라서 위와 같이 만들어진 배열은 메모리를 할당하지 않는 10개의 empty slot을 가진 배열이다 다만 length 프로퍼티만이 10으로 설정되어있는 상태이다

```js
const a = Array(10);
a.forEach((v,i)=>{
  console.log(v); // 아무것도 출력되지 않는다
})
```
위와 같이 forEach문으로 돌려도 아무것도 출력되지 않는다
아예 순회가 되지 않는다
왜냐, array method는 항상 0번째 주소를 갖는다
그런데 위의 `a`는 0번째 주소에 empty가 들어가있기 때문에 순회가 되지 않는 것이다

그럼 중간값이 있다면 다를까?
```js
const b = Array(10);
b[4] = 42;
b.forEach((v,i)=>{
  console.log(v); // 42만 출력된다
})
```
위와 같이 4번째 인덱스에 값을 넣어주면 forEach문으로 돌렸을 때 42만 출력된다
왜냐 0~3,5~9번째 인덱스는 empty이기 때문에 순회가 되지 않고 4번째 인덱스만 순회가 돈다
그럼 이 배열의 주소위치는 어떻게 될까?

### 희소 배열(Sparse Array)의 내부 동작

-   **결론**: 희소 배열은 전통적인 배열처럼 **연속된 메모리 주소를 갖지 않는다.**
-   **동작 방식**: JavaScript 엔진은 배열을 효율적으로 다루기 위해 내부적으로 두 가지 모드(Fast/Dictionary)를 사용하며, 희소 배열은 **사전(Dictionary) 모드**로 동작한다.

1.  **빽빽한 배열 (Dense Array) - "Fast Elements" 모드**
    -   **예시**: `const arr = [10, 20, 30];`
    -   **메모리 구조**: C언어 배열처럼 **연속된 메모리 공간**에 값을 저장하여 인덱스 접근(O(1))이 매우 빠르다.

2.  **희소 배열 (Sparse Array) - "Dictionary" 모드**
    -   **예시**: `const b = Array(10); b[4] = 42;`
    -   **메모리 구조**: 메모리 낭비를 막기 위해 **해시맵(Hash Map)과 유사한 방식**으로 관리된다.
        -   `Array(10)`: 10개의 메모리 공간을 할당하는 것이 아니라, `length`가 10인 객체를 생성한다.
        -   `b[4] = 42`: `b` 객체에 `'4'`라는 키(key)와 `42`라는 값(value)을 가진 프로퍼티를 추가한다.

    ```
    // 희소 배열의 개념적 메모리 구조
    b ---> {
              '4': 42,
              length: 10
           }
    ```
    -   결과적으로 `b` 배열의 주소 위치는 연속적이지 않으며, 값이 할당된 인덱스('4')만 프로퍼티로 존재하고 메모리를 차지한다.

-   **`forEach`가 `empty`를 건너뛰는 이유**: `forEach`, `map` 등의 메서드는 0부터 `length-1`까지 모든 인덱스를 순회하는 것이 아니라, 해당 객체에 **실제로 존재하는 프로퍼티(key)들만 순회**하기 때문이다.


array를 만들때는 아래와 같이 만드는것이 정석적인 방법이다
```js
Array.from({ length: 5 }, (_, i) => i+1);
// [1, 2, 3, 4, 5]
```