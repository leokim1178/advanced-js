클로저는 함수형 프로그래밍 언어가 가지고 있는 가장 대표적인 특징 중 하나다

클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다

상위 스코프의 식별자를 참조하는 하위 스코프의 함수가 더 오래 살아있는 것


```js
let userFn;
{
    const privateUser = {id:1, name:'taeyeong'};
    userFn = ()=> privateUser; // 이 userFn 변수가 하위 스코프의 privateUser를 참조하고 있다
}
// block이 끝나면서 이 block의 BlockExecutionContext는 사라지지만
// privateUser를 userFn이 계속 참조하고 있기 때문에 BlockLexicalEnvironment는 사라지지 않는다
userFn().age =30; // 실제로는 privateUser가 변경된다
console.log(userFn()); // {id:1, name:'taeyeong', age:30}
```


```js
// 비순수함수
let count=0; // 외부변수(오염가능)
function counter(){
    return ++count;
}
console.log(counter()); //1
console.log(counter()); //2
count=500; // risky : 함수의 바깥쪽에 있는 변수를 외부에서 오염시킬 수 있다
console.log(counter()); //3 -> 501
```

```js
// 순수함수 + 클로저
function counter(){
    let count=0;
    return function x(){
        return ++count;
    }
}

const counter1=counter(); 
// 여기서 counter1의 실행컨텍스트는 ECS에서 소멸된다
// 그러나 function x가 function object가 존재하게 되었고 이 function x는 counter()함수의 function lexical environment를 참조하고 있다
// 따라서 counter()함수의 function lexical environment는 소멸되지 않고 남아있게 된다
const counter2=counter(); // 새로운 counter, 새로운 environmentRecord 생성
// 마찬가지로 counter2도 execution context가 생서되었다가 소멸되지만
// counter2와는 다른 function lexical environment를 갖게 된다
// 따라서 counter1과 counter2는 각각 다른 lexical environment를 참조하게 되면서 다른 count 변수를 갖게 된다
// 각각의 클로저가 자신만의 count 변수를 갖고 있다
console.log(counter1()); // 1
console.log(counter1()); // 2
console.log(counter2()); // 1
```

### currying
**커링(Currying)** 기법이란, **여러 개의 인자를 받는 함수를, 단 하나의 인자만 받는 여러 개의 함수로 쪼개는(변환하는) 기법**을 말한다.

쉽게 말해, `f(a, b, c)`처럼 한 번에 여러 인자를 받던 함수를 `f(a)(b)(c)`처럼 함수가 함수를 연쇄적으로 반환하는 형태로 만드는 것이다.

#### 핵심 원리
커링은 **클로저**를 적극적으로 활용한다. 바깥쪽 함수가 실행되면서 전달받은 인자(`a`)를 기억하고, 그 인자를 사용할 수 있는 안쪽 함수를 반환한다. 이 과정이 모든 인자가 전달될 때까지 반복된다.

#### 예시
**일반 함수:**
```javascript
function sum(a, b, c) {
  return a + b + c;
}
console.log(sum(1, 2, 3)); // 6
```

**커링을 적용한 함수:**
```javascript
function curriedSum(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
}
console.log(curriedSum(1)(2)(3)); // 6
```

#### 커링의 장점: 함수의 재사용성
커링의 가장 큰 장점은 **함수를 재사용하고 조합하기 용이하다**는 점이다. 인자를 미리 "채워 넣어" 새로운 함수를 쉽게 만들어낼 수 있다.

```javascript
const curriedSum = (a) => (b) => (c) => a + b + c;

// 'a' 인자에 10을 미리 채워넣어, 10을 더하는 새로운 함수를 만듦
const addTen = curriedSum(10);

console.log(addTen(5)(3));  // 18 (10 + 5 + 3)
console.log(addTen(10)(20)); // 40 (10 + 10 + 20)

// 'a'와 'b' 인자를 미리 채워넣어 더 특화된 함수를 만듦
const addTenAndFive = addTen(5);
console.log(addTenAndFive(3)); // 18 (10 + 5 + 3)
```
이처럼 커링을 사용하면 특정 인자를 고정시켜 둔 **새로운 함수를 동적으로 생성**할 수 있어, 코드의 재사용성을 높이고 함수형 프로그래밍에서 유연한 함수 조합을 가능하게 한다.


### memoized function
