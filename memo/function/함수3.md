# `setTimeout`과 반복문의 스코프 문제

`for` 반복문 내에서 `setTimeout`을 사용할 때 `var`와 `let`의 스코프 차이로 인해 발생하는 문제를 정리한다.

## 1. `var` 사용 시 문제점

```javascript
// 문제 코드
for (var i = 0; i < 5; i += 1) {
  setTimeout(() => console.log(i), 100);
}
// 결과: 5, 5, 5, 5, 5
```

-   **원인**:
    1.  `setTimeout`의 콜백은 비동기로 실행된다.
    2.  `for` 반복문은 동기적으로 먼저 모두 실행을 마친다.
    3.  `var`로 선언된 `i`는 함수 스코프를 가지므로, 반복문이 끝난 후에도 `i`는 `5`라는 최종값을 유지한다.
    4.  콜백 함수들이 실행될 시점에는 모두 `i`의 최종값인 `5`를 참조하게 된다.

## 2. 해결 방안

### 방법 1: `let` 사용 (권장)

`let`은 블록 스코프를 가지므로, 반복마다 독립적인 `i` 변수가 생성된다.

```javascript
for (let i = 0; i < 5; i += 1) {
  setTimeout(() => console.log(i), 100);
}
// 결과: 0, 1, 2, 3, 4
```

-   각 콜백 함수는 자신이 생성된 시점의 `i` 값을 기억(클로저)하므로 의도대로 동작한다.

### 방법 2: `setTimeout`의 세 번째 인자 활용

`setTimeout`의 세 번째 인자로 값을 넘기면, 콜백 함수가 실행될 때 해당 값을 인자로 받는다.

```javascript
for (var i = 0; i < 5; i += 1) {
  setTimeout(console.log, 100, i);
}
// 결과: 0, 1, 2, 3, 4
```

-   반복 시점의 `i` **값**이 복사되어 `setTimeout`에 전달되므로, 변수 `i`의 최종값과 무관하게 동작한다.

### 방법 3: IIFE (즉시 실행 함수) 사용

`let`이 없던 시절에 사용하던 클로저를 활용한 방법이다.

```javascript
for (var i = 0; i < 5; i++) {
  ((j) => {
    setTimeout(() => console.log(j), 100);
  })(i);
}
// 결과: 0, 1, 2, 3, 4
```

-   반복마다 새로운 함수 스코프가 생성되고, `i`의 값이 `j`로 복사되어 유지된다.



### unary 함수