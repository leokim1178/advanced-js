# V8 엔진과 메모리 구조

## String 객체와 Constant Pool
```js
c= new String("hello world");
typeof c // "object"
%DebugPrint(c) // 0x9990980a69
```
```shell
DebugPrint: 0x2d75a2881f69: [JSPrimitiveWrapper]
 - map: 0x3173acde91c1 <Map[32](FAST_STRING_WRAPPER_ELEMENTS)> [FastProperties]
 - prototype: 0x0be39d565c21 <Object map = 0x38d25df17751 value = 0x08f452a400c9 <String[0]: #>>
 - elements: 0x08f452a40c31 <FixedArray[0]> [FAST_STRING_WRAPPER_ELEMENTS]
 - value: 0x9990980a69  <String[12]: #hello, world>
 - properties: 0x08f452a40c31 <FixedArray[0]>
 - All own properties (excluding elements): {
    0x8f452a417c9: [String] in ReadOnlySpace: #length: 0x08f452a71d99 <AccessorInfo name= 0x08f452a417c9 <String[6]: #length>, data= 0x08f452a40069 <undefined>> (const accessor descriptor), location: descriptor
 }
0x3173acde91c1: [Map] in OldSpace
 - map: 0x38d25df011a1 <MetaMap (0x38d25df01231 <NativeContext[287]>)>
 - type: JS_PRIMITIVE_WRAPPER_TYPE
 - instance size: 32 
 - inobject properties: 0
 - unused property fields: 0
 - elements kind: FAST_STRING_WRAPPER_ELEMENTS
 - enum length: invalid
 - stable_map
 - back pointer: 0x08f452a40069 <undefined>
 - prototype_validity cell: 0x08f452a41249 <Cell value= 1>
 - instance descriptors (own) #1: 0x3173acde9209 <DescriptorArray[1]>
 - prototype: 0x0be39d565c21 <Object map = 0x38d25df17751 value = 0x08f452a400c9 <String[0]: #>>
 - constructor: 0x3173acde9099 <JSFunction String (sfi = 0x8f452a7cb09)>
 - dependent code: 0x08f452a40c51 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0
```
c는 String 객체이기에 object 타입이다  
위와 같이 DebugPrint를 해보면 c의 메모리 주소는 a와 b와 같이 0x9990980a69이다(예시)  
따라서 String 객체도 constant pool에 저장되는것을 알 수 있다  
그런데 보면 instance size가 32바이트로 고정되어 있다  
32바이트는 메모리 주소라고 보면 된다  
즉 String 객체는 primitive type이면서도 object 타입인 특이한 케이스

## 숫자형과 메모리
### 작은 숫자 (4바이트 이하)
```js
const f = 900090009;
%DebugPrint(f) 
// DebugPrint: Smi: 0x35a64899 (900090009)
```
f는 4바이트 이하이기에 constant pool에 넣지 않는다

### 큰 숫자 (4바이트 초과)
```js
const g = 9000900090009000;
%DebugPrint(g)
```
```shell
> %DebugPrint(g)
DebugPrint: 0x371775d78869: [HeapNumber] in OldSpace
 - map: 0x08f452a40dc9 <Map[16](HEAP_NUMBER_TYPE)>
 - value: 9000900090009000.0
0x8f452a40dc9: [Map] in ReadOnlySpace
 - map: 0x08f452a40841 <MetaMap (0x08f452a40099 <null>)>
 - type: HEAP_NUMBER_TYPE
 - instance size: 16
 - elements kind: HOLEY_ELEMENTS
 - enum length: invalid
 - stable_map
 - back pointer: 0x08f452a40069 <undefined>
 - prototype_validity cell: 0
 - instance descriptors (own) #0: 0x08f452a40c91 <DescriptorArray[0]>
 - prototype: 0x08f452a40099 <null>
 - constructor: 0x08f452a40099 <null>
 - dependent code: 0x08f452a40c51 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0
```
그러나 위와 같이 g는 4바이트를 초과, 5바이트 이상이기에 constant pool에 저장된다  
즉 V8엔진에서는 모든 숫자가 8바이트가 아닌것을 알 수 있다

### 소수점
```js
j=1.100;
%DebugPrint(j)
```
```shell
> %DebugPrint(j)
DebugPrint: 0x5b9c35c4449: [HeapNumber] in OldSpace
 - map: 0x08f452a40dc9 <Map[16](HEAP_NUMBER_TYPE)>
 - value: 1.1
0x8f452a40dc9: [Map] in ReadOnlySpace
 - map: 0x08f452a40841 <MetaMap (0x08f452a40099 <null>)>
 - type: HEAP_NUMBER_TYPE
 - instance size: 16
 - elements kind: HOLEY_ELEMENTS
 - enum length: invalid
 - stable_map
 - back pointer: 0x08f452a40069 <undefined>
 - prototype_validity cell: 0
 - instance descriptors (own) #0: 0x08f452a40c91 <DescriptorArray[0]>
 - prototype: 0x08f452a40099 <null>
 - constructor: 0x08f452a40099 <null>
 - dependent code: 0x08f452a40c51 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0
```
마찬가지로 소수점도 4바이트 초과이다  
float와 double은 8바이트이니까

## 문자열 인코딩
### 한글 (2바이트)
```js
x="세종대왕";
%DebugPrint(x)
```
```shell
> %DebugPrint(x)
DebugPrint: 0x5b9c35c4c19: [String] in OldSpace: u#\uc138\uc885\ub300\uc655
0x8f452a40649: [Map] in ReadOnlySpace
 - map: 0x08f452a40841 <MetaMap (0x08f452a40099 <null>)>
 - type: INTERNALIZED_TWO_BYTE_STRING_TYPE
 - instance size: variable
 - elements kind: HOLEY_ELEMENTS
 - enum length: invalid
 - stable_map
 - non-extensible
 - back pointer: 0x08f452a40069 <undefined>
 - prototype_validity cell: 0
 - instance descriptors (own) #0: 0x08f452a40c91 <DescriptorArray[0]>
 - prototype: 0x08f452a40099 <null>
 - constructor: 0x08f452a40099 <null>
 - dependent code: 0x08f452a40c51 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0
```
한글은 INTERNALIZED_TWO_BYTE_STRING_TYPE, 2바이트 문자열 타입이다

## Date 객체
```js
const x1=new Date();
%DebugPrint(x1)
```
```shell
DebugPrint: 0x35fe63cde29: [JSDate]
 - map: 0x38d25df2fe39 <Map[96](HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x38d25df30399 <Object map = 0x38d25df2fe81>
 - elements: 0x08f452a40c31 <FixedArray[0]> [HOLEY_ELEMENTS]
 - value: 0x035fe63cde89 <HeapNumber 1763887818620.0>
 - time = NaN

 - properties: 0x08f452a40c31 <FixedArray[0]>
 - All own properties (excluding elements): {}
0x38d25df2fe39: [Map] in OldSpace
 - map: 0x38d25df011a1 <MetaMap (0x38d25df01231 <NativeContext[287]>)>
 - type: JS_DATE_TYPE
 - instance size: 96
 - inobject properties: 0
 - unused property fields: 0
 - elements kind: HOLEY_ELEMENTS
 - enum length: invalid
 - stable_map
 - back pointer: 0x08f452a40069 <undefined>
 - prototype_validity cell: 0x08f452a41249 <Cell value= 1>
 - instance descriptors (own) #0: 0x08f452a40c91 <DescriptorArray[0]>
 - prototype: 0x38d25df30399 <Object map = 0x38d25df2fe81>
 - constructor: 0x38d25df2fd11 <JSFunction Date (sfi = 0x8f452a7da49)>
 - dependent code: 0x08f452a40c51 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0
```
date 객체도 똑같이 constant pool에 저장된다

## Symbol과 고유성
symbol은 대표적인 primitive type이다
```js
s1= Symbol("sym");
s2= Symbol("sym");
s1 === s2 // false
%DebugPrint(s1)
%DebugPrint(s2)
```
위와 같이 동일한 값을 가지는 symbol을 두개 선언했을때도 서로 다른 값을 가진다  
symbol 객체의 특징은 절대 같은 값을 주지 않는다  
두개를 debugPrint해보면 서로 다른 메모리 주소를 가지는것을 알 수 있다

```shell
> %DebugPrint(s1)
DebugPrint: 0x5b9c35c6389: [Symbol] in OldSpace
 - map: 0x08f452a407f9 <Map[24](SYMBOL_TYPE)>
 - hash: 190962823
 - description: 0x0300d8083901 <String[3]: #sym>
 - private: 0
 - private_name: 0
 - private_brand: 0
 - is_interesting_symbol: 0
 - is_well_known_symbol: 0
0x8f452a407f9: [Map] in ReadOnlySpace
 - map: 0x08f452a40841 <MetaMap (0x08f452a40099 <null>)>
 - type: SYMBOL_TYPE
 - instance size: 24
 - elements kind: HOLEY_ELEMENTS
 - enum length: invalid
 - stable_map
 - non-extensible
 - back pointer: 0x08f452a40069 <undefined>
 - prototype_validity cell: 0
 - instance descriptors (own) #0: 0x08f452a40c91 <DescriptorArray[0]>
 - prototype: 0x08f452a40099 <null>
 - constructor: 0x08f452a40099 <null>
 - dependent code: 0x08f452a40c51 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0
```

```shell
> %DebugPrint(s2)
DebugPrint: 0x5b9c35c6901: [Symbol] in OldSpace -> 심볼타입 맵, 심볼 테이블이라고 부른다
 - map: 0x08f452a407f9 <Map[24](SYMBOL_TYPE)>
 - hash: 293190033
 - description: 0x0300d8083901 <String[3]: #sym>
 - private: 0
 - private_name: 0
 - private_brand: 0
 - is_interesting_symbol: 0
 - is_well_known_symbol: 0
0x8f452a407f9: [Map] in ReadOnlySpace
 - map: 0x08f452a40841 <MetaMap (0x08f452a40099 <null>)>
 - type: SYMBOL_TYPE
 - instance size: 24
 - elements kind: HOLEY_ELEMENTS
 - enum length: invalid
 - stable_map
 - non-extensible
 - back pointer: 0x08f452a40069 <undefined>
 - prototype_validity cell: 0
 - instance descriptors (own) #0: 0x08f452a40c91 <DescriptorArray[0]>
 - prototype: 0x08f452a40099 <null>
 - constructor: 0x08f452a40099 <null>
 - dependent code: 0x08f452a40c51 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0
```
해시값이 다른것을 알 수 있다

### UUID와 Symbol
그래서 uuid도 형식이 여러가지인데  
긴 숫자가 있고 짧은 숫자가 있다  
짧은건 10의 -3승초  
긴건 10의 -6승초 단위로 생성된다  
따라서 짧은 uuid는 동시에 같은 uuid가 생성될 확률이 높다

### 심볼 테이블
심볼테이블은 제조사마다 다르지만 주소값을 중복되지 않게 한다  
js는 싱글스레드 하에서 uuid, pid, 시간(10의 -6승초까지)에 따라 다르게 심볼을 생성한다  
싱글스레드는 원칙적으로 동시에 두개의 uuid를 생성하지 못한다  
다른 노드가 심볼을 생성한다 하더라도 pid가 다르기 때문에 중복이 안된다  
따라서 중복이 안된다

## BigInt
BigInt도 primitive type이다
```js
b1= BigInt(90009000900090009000);
```
```shell
> %DebugPrint(b1)
DebugPrint: 0x2d75a2891c49: [BigInt]
 - map: 0x08f452a40e11 <Map(BIG_INT_BASE_TYPE)>
- length: 2
- sign: 0
- digits:
    0xe120356e35ae0000
    0x4
0x8f452a40e11: [Map] in ReadOnlySpace
 - map: 0x08f452a40841 <MetaMap (0x08f452a40099 <null>)>
 - type: BIG_INT_BASE_TYPE
 - instance size: variable
 - elements kind: HOLEY_ELEMENTS
 - enum length: invalid
 - stable_map
 - back pointer: 0x08f452a40069 <undefined>
 - prototype_validity cell: 0
 - instance descriptors (own) #0: 0x08f452a40c91 <DescriptorArray[0]>
 - prototype: 0x08f452a40099 <null>
 - constructor: 0x08f452a40099 <null>
 - dependent code: 0x08f452a40c51 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0
```
따라서 BigInt도 constant pool에 저장된다  
그 외에 MAX_SAFE_INTEGER,MIN_SAFE_INTEGER도 상수로, constant pool에 저장된다

## undefined, null, NaN
undefinded와 null, nan은 constant pool에 저장될까?
```js
u= undefined;
%DebugPrint(u)
n= null;
%DebugPrint(n)
a= 7 *"a"; // NaN
%DebugPrint(a)
```
```shell
> %DebugPrint(u)
DebugPrint: 0x8f452a40069: [Oddball] in ReadOnlySpace: #undefined
0x8f452a40889: [Map] in ReadOnlySpace
> %DebugPrint(n)
DebugPrint: 0x8f452a40099: [Oddball] in ReadOnlySpace: #null
0x8f452a408d1: [Map] in ReadOnlySpace
> %DebugPrint(a)
DebugPrint: 0x35fe63d47a1: [HeapNumber]
 - map: 0x08f452a40dc9 <Map[16](HEAP_NUMBER_TYPE)>
```
셋 다 constant pool에 저장되는 것을 알 수 있다  
HOLEY_ELEMENTS라는 단어가 자주 나오는데  
HOLEY_ELEMENTS는 배열에 빈 공간이 있을수 있다는 뜻이다  
모두 상수로 저장된다

## 배열의 내부 구조
### 배열과 hole_value
```js
arr1= [1,2,3,,5];
%DebugPrint(arr1)
```
```shell
> %DebugPrint(arr1)
DebugPrint: 0x35fe63f0aa9: [JSArray]
 - map: 0x38d25df0a539 <Map[32](HOLEY_SMI_ELEMENTS)> [FastProperties]
 - prototype: 0x38d25df03b01 <JSArray[0]>
 - elements: 0x13cafdf86689 <FixedArray[5]> [HOLEY_SMI_ELEMENTS (COW)]
 - length: 5
 - properties: 0x08f452a40c31 <FixedArray[0]>
 - All own properties (excluding elements): {
    0x8f452a417c9: [String] in ReadOnlySpace: #length: 0x08f452a71c19 <AccessorInfo name= 0x08f452a417c9 <String[6]: #length>, data= 0x08f452a40069 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x13cafdf86689 <FixedArray[5]> {
           0: 1
           1: 2
           2: 3
           3: 0x08f452a40c69 <the_hole_value>
           4: 5
 }
0x38d25df0a539: [Map] in OldSpace
 - map: 0x38d25df011a1 <MetaMap (0x38d25df01231 <NativeContext[287]>)>
 - type: JS_ARRAY_TYPE
```
4번째 element가 비어있는것을 알 수 있다  
비어있는 요소이 주소는 0x08f452a40841이다(예시)  
그렇다면 이 비어있는 요소의 주소값은 모두 비어있는 걸 뜻하는 hole_value, 0x08f452a40841로 상수로 된다는것을 알 수 있다  
보면 타입이 JS_ARRAY_TYPE인것을 알 수 있다  
HOLEY_SMI_ELEMENTS라는 단어도 보인다  
MAP의 종류가 CONSTANT_POOL에 상당히 많다  
이렇게 MAP으로 분류를 해놓는것이다

### 배열 요소의 주소 공유
그럼 배열 내에 위치한 값들도 주소를 공유할까?
```js 
f5="55";
%DebugPrint(f5)
arr2= [1,2,3,,"55"];
%DebugPrint(arr2)
```
```shell
> %DebugPrint(f5)
DebugPrint: 0x13cafdf87319: [String] in OldSpace: #55
0x8f452a40691: [Map] in ReadOnlySpace
 - map: 0x08f452a40841 <MetaMap (0x08f452a40099 <null>)>
 - type: INTERNALIZED_ONE_BYTE_STRING_TYPE
 - instance size: variable
 - elements kind: HOLEY_ELEMENTS
 - enum length: invalid
 - stable_map
 - non-extensible
 - back pointer: 0x08f452a40069 <undefined>
 - prototype_validity cell: 0
 - instance descriptors (own) #0: 0x08f452a40c91 <DescriptorArray[0]>
 - prototype: 0x08f452a40099 <null>
 - constructor: 0x08f452a40099 <null>
 - dependent code: 0x08f452a40c51 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0
> %DebugPrint(arr2)
DebugPrint: 0x2db9f9e01a79: [JSArray]
 - map: 0x0be39d579311 <Map[32](HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x38d25df03b01 <JSArray[0]>
 - elements: 0x13cafdf877f9 <FixedArray[5]> [HOLEY_ELEMENTS (COW)]
 - length: 5
 - properties: 0x08f452a40c31 <FixedArray[0]>
 - All own properties (excluding elements): {
    0x8f452a417c9: [String] in ReadOnlySpace: #length: 0x08f452a71c19 <AccessorInfo name= 0x08f452a417c9 <String[6]: #length>, data= 0x08f452a40069 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x13cafdf877f9 <FixedArray[5]> {
           0: 1
           1: 2
           2: 3
           3: 0x08f452a40c69 <the_hole_value>
           4: 0x13cafdf87319 <String[2]: #55>
 }
0xbe39d579311: [Map] in OldSpace
 - map: 0x38d25df011a1 <MetaMap (0x38d25df01231 <NativeContext[287]>)>
 - type: JS_ARRAY_TYPE
 - instance size: 32
 - inobject properties: 0
 - unused property fields: 0
 - elements kind: HOLEY_ELEMENTS
 - enum length: 0
 - stable_map
 - back pointer: 0x38d25df03a71 <Map[32](PACKED_ELEMENTS)>
 - prototype_validity cell: 0x08f452a41249 <Cell value= 1>
 - instance descriptors (own) #1: 0x3173acdfa371 <DescriptorArray[1]>
 - prototype: 0x38d25df03b01 <JSArray[0]>
 - constructor: 0x38d25df06bb9 <JSFunction Array (sfi = 0x8f452a7bc09)>
 - dependent code: 0x08f452a40c51 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0
```
보면 0x13cafdf87319라는 동일한 주소값을 가지는것을 알 수 있다  
따라서 배열 내에 위치한 값들도 주소를 공유한다는것을 알 수 있다  
이건 STRING_MAP에 있을 것이다

## 객체의 내부 구조
### 객체와 Property Key
```js
obj = {
   "8":45000000000000000,
   "9":257,
   id: 1,
   AB: 2,    
   "32000000000": 32000000000,
   [Symbol('s')]:"ss"
};
%DebugPrint(obj)
```
```shell
> %DebugPrint(obj)
DebugPrint: 0x2a8e94f413d9: [JS_OBJECT_TYPE]
 - map: 0x3326919399f9 <Map[56](HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x38d25df2bbd1 <Object map = 0x38d25df01bd1>
 - elements: 0x2a8e94f41859 <FixedArray[29]> [HOLEY_ELEMENTS]
 - properties: 0x08f452a40c31 <FixedArray[0]>
 - All own properties (excluding elements): {
    0x8f452a477a1: [String] in ReadOnlySpace: #id: 1 (const data field 0), location: in-object
    0x33269190d4e1: [String] in OldSpace: #AB: 2 (const data field 1), location: in-object
    0x33269192bde1: [String] in OldSpace: #32000000000: 0x2a8e94f41951 <HeapNumber 32000000000.0> (const data field 2), location: in-object
    0x3326919399e1 <Symbol: s>: 0x33269190f471 <String[2]: #ss> (const data field 3), location: in-object
 }
 - elements: 0x2a8e94f41859 <FixedArray[29]> {
         0-7: 0x08f452a40c69 <the_hole_value>
           8: 0x332691939939 <HeapNumber 4.5e+16>
           9: 257
       10-28: 0x08f452a40c69 <the_hole_value>
 }
```
object도 constant pool에 저장되는것을 알 수 있다  
객체의 속성들도 주소를 공유하는것을 알 수 있다  
보면 property key가 8,9가 있기 때문에 29번까지의 Array가 생성된것을 알 수 있다  
그렇기 떄문에 property key를 함부로 큰 숫자를 쓰면 불리하다

### 객체에 속성 추가시 메모리 할당
```shell
> obj[33]=33
33
> %DebugPrint(obj)
DebugPrint: 0x33269193f9e1: [JS_OBJECT_TYPE] in OldSpace
 - map: 0x3326919399f9 <Map[56](HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x38d25df2bbd1 <Object map = 0x38d25df01bd1>
 - elements: 0x355289b0a069 <FixedArray[67]> [HOLEY_ELEMENTS]
 - properties: 0x08f452a40c31 <FixedArray[0]>
 - All own properties (excluding elements): {
    0x8f452a477a1: [String] in ReadOnlySpace: #id: 1 (const data field 0), location: in-object
    0x33269190d4e1: [String] in OldSpace: #AB: 2 (const data field 1), location: in-object
    0x33269192bde1: [String] in OldSpace: #32000000000: 0x33269193fbf1 <HeapNumber 32000000000.0> (const data field 2), location: in-object
    0x3326919399e1 <Symbol: s>: 0x33269190f471 <String[2]: #ss> (const data field 3), location: in-object
 }
 - elements: 0x355289b0a069 <FixedArray[67]> {
         0-7: 0x08f452a40c69 <the_hole_value>
           8: 0x332691939939 <HeapNumber 4.5e+16>
           9: 257
       10-32: 0x08f452a40c69 <the_hole_value>
          33: 33
       34-66: 0x08f452a40c69 <the_hole_value>
 }
```
이렇게 33이라는 property key를 추가해서 넣어보자  
이렇게 했을떄, elements의 크기가 67로 늘어난것을 알 수 있다  
34~66까지를 왜 만들었을까  
v8엔진에서는 추가로 할당할 확률이 높다 생각하고 미리 메모리를 할당해놓는다  
따라서 object의 property key로는 작은 숫자를 사용하는게 유리하다

## 배열의 본질
### 배열은 객체다
배열을 좀 더 알아보자  
예시 배열을 하나 만들어보자
```js
a=[1,2];
```
위와 같이 배열을 만들면 a가 &100이라는 메모리 주소를 가진다고 가정하자  
그럼 a라는 변수에는 &100이라는 메모리 주소가 들어간다  
이 &100은 항상 이 array의 첫번째 원소를 가리킨다  
즉 a[0]은 &100에 있는 값을 읽어오는 것이다  
비밀이 하나 있다  
배열은 사실 객체다  
배열은 사실 아래와 같다
```js
a={
  0:1,
  1:2,
  length:2
}
```
즉 배열은 객체의 특수한 형태다  
그래서 array가 아무리 원소가 많아도 arr.length로 길이를 알 수 있는 것이다  
그렇다고 해도 O(1)은 아니다  
이건 나중에 다루자

## Dense Array vs Sparse Array (Holey Array)
그런데 js의 array는 타입이 다 다를 수 있다
```js
a=[1,"2","AB",true,null,undefined,{id:1},[3,4],function(){console.log("hi")}];
```
뭐 이렇게 말이다  
타입이 다 다르기 떄문에 dense array와 holey array로 나뉜다

### Dense Array
dense array는 타입이 모두 동일한 배열이다  
이런 경우 length가 필요가 없다  
왜냐 시작주소를 가지고 있는데 전체 사이즈에서 나누기 타입 크기를 하면 length를 알 수 있기 때문이다  
예를 들면
```js
a=[1,2,3,4,5];
```
이런 배열이 있다고 하자  
이 배열의 시작주소가 &200이고 각 원소가 4바이트라고 하면  
전체 사이즈는 20바이트이다  
따라서 length는 20/4 = 5가 된다  
따라서 dense array는 length 프로퍼티가 필요가 없다  
dense array는 그래서 조회할때 엄청나게 빠르다  
그런데 끼워넣을수가 없기 때문에 배열을 새로 만들어서 이사를 가야한다  
이렇게 끼워넣는 부담이 크다

### Sparse Array (Holey Array)
반면에 sparse array, holey array는 타입이 다른 배열이다  
따라서 사이즈가 고정적이지 않다  
그래서 sparse array는 어떤 구조일지 알아보자
```js
obj={
   id:1,
   name: 2,
   age:33
}
```
위와 같은 객체가 있다고 하자  
위의 property가 어떻게 되어있는지 보자
```js
{key: "id", value:1, next: {key:"name", value:2, next:{key:"age", value:33, next:null}}}
```
이런식으로 linked list로 되어있다
```js
Object.keys(obj) // ["id","name","age"]
```
이렇게 keys메서드를 사용하면 key값들을 순서대로 준다  
왜냐  
next를 통해 다음 property로 알 수 있기 떄문이다

sparse array도 마찬가지다
```js
a=[1,"2","AB",true,null,undefined,{id:1},[3,4],function(){console.log("hi")}];
```
이를 linked list로 표현하면
```js
{index:0, value:1, next:{index:1, value:"2", next:{index:2, value:"AB", next:{index:3, value:true, next:{index:4, value:null, next:{index:5, value:undefined, next:{index:6, value:{id:1}, next:{index:7, value:[3,4], next:{index:8, value:function(){console.log("hi")}, next:null}}}}}}}}}}
```
뭐 이런식으로 linked list 구조로 되어있는 것이다

그래서 array[0]이라고 한다면 사실상은 array['0']으로 바뀌어서 객체의 프로퍼티를 읽어오는 것이다

arr의 주소값 &100을 arr[0]이 갖는다  
여기서 링크드리스트의 next값을 따라가면서 다음 값을 읽어오는 것이다  
그렇기 때문에 length까지 가서 읽으려면 O(n)이 걸리는 것이다

그런데 sparse array는 끼워넣기로 따지면 쉽다  
아무데나 끼워넣어도 linked list의 next값만 바꿔주면 되기 때문이다  
따라서 sparse array는 끼워넣기가 쉽고 dense array는 조회가 빠른 것이다

### 배열 값 변경과 메모리
그런데 0번째가 바뀌면 안되지 않을까?
```js
a=[1,2,3];
a[0]=a[2];
```
이렇게 하면 0번째에 3이 들어가게 된다  
그럼 a가 &100이라는 주소를 가진다면
```
&100 -> 3
&104 -> 2
&108 -> 1
```
이렇게 되는거 아닐까?  
그렇지 않고 다음과 같다
```
&100 -> 3
&104 -> 2
&108 -> 3
```
즉 0번째와 2번째가 같은 값을 가지게 된다

1이라는 값은 primitive type이기에 constant pool에 없고 stack에 있다  
따라서 &100과 &108이 같은 constant pool의 주소값을 가지게 된다  
배열 자체는 arrayy 객체이기에 heap에 있지만  
배열 내의 primitive type 값들은 stack에 있는 constant pool의 주소값을 가지게 된다  
따라서 1이 바뀌게 되면 &100이 가리키는 constant pool의 주소가 바뀌는 것이지  
&108이 가리키는 constant pool의 주소값은 바뀌지 않는다

## 타입 비교와 메모리
### Number vs BigInt
그럼 다시, 원시 타입으로 돌아가서
```js
const n=123;
const bi = 123n;
```
위와 같이 선언을 하면 n은 stack에, bi는 heap에 저장된다  
n은 4바이트 이하이기에 stack에 저장되고  
bi는 4바이트 초과이기에 heap에 저장된다  
따라서 n은 constant pool에 저장되고 bi는 constant pool에 저장되지 않는다
```js
n==bi // true
n===bi // false
```
n==bi는 true가 된다  
값을 따지면 동일하기 때문이다  
하지만 n과 bi는 엄연히 다른 타입이기에 false가 된다

### Boolean vs Boolean 객체
```js
const b=true;
const bb = new Boolean(); // 아무것도 안주면 false
```
위와 같이 선언을 하면 b는 stack에, bb는 heap에 저장된다  
b는 1바이트 이하이기에 stack에 저장되고  
bb는 객체이기에 heap에 저장된다  
따라서 b는 constant pool에 저장되고 bb는 constant pool에 저장되지 않는다
```js
b==bb // true
b===bb // false
```
값을 따지면 동일하므로 b==bb는 true가 된다  
하지만 b와 bb는 엄연히 다른 타입이기에 b===bb는 false가 된다

### Symbol의 고유성
반면 심볼은 절대 같을 수가 없다
```js
const s1= Symbol("sym");
const s2= Symbol("sym");
s1==s2 // false
s1===s2 // false
```
위와 같이 동일한 값을 가지는 심볼을 두개 선언했을때도 서로 다른 값을 가진다  
심볼 객체의 특징은 절대 같은 값을 주지 않는다  
따라서 s1==s2도 false가 되고 s1===s2도 false가 된다

## Symbol과 객체 Property
객체 안에 symbol이 들어가있는 경우도 보자
```js
obj = {
   id: 1,
   [Symbol()]:123}
obj.id // 1
Object.keys(obj) // ["id"]
```
위와 같이 symbol이 객체 안에 들어가 있어도  
obj.id는 1이 되고  
Object.keys(obj)는 ["id"]가 된다  

그래서 Reflect를 사용해보자  
(Reflect는 오픈소스 라이브러리였는데 자바스크립트로 들어간 영광스러운 라이브러리 )
```js
Reflect.ownKeys(obj) // ["id", Symbol()]
```
위와 같이 Reflect.ownKeys를 사용하면 symbol도 key값으로 가져온다
```js
arr1 = Reflect.ownKeys(obj);
arr[1] // Symbol()
obj[arr1[1]] // 123
```
위와 같이 symbol도 key값으로 사용할 수 있다  
접근하게 하려면 이렇게 어렵게 심볼을 만들지 않았겠지  
왜 이렇게 했냐면 다른 키가 와가지고 이를 덮어쓸까봐 이를 방지하기 위해서이다

### Symbol.iterator
그래서 대표적으로 Symbol.iterator라는게 있다
```js
Symbol.iterator
obj[Symbol.iterator]
```
이건 함수명인데 이렇게 사용하면 객체가 이터러블 하게 만들어준다

## undefined vs null
다음은 undefined와 null이다
```js
const u= undefined;
const nu = null;
u== nu // true
u=== nu // false
```
위와 같이 선언을 하면 u와 nu는 모두 stack에 저장된다  
상수로서 존재한다  
값이 같기 때문에 u== nu는 true가 된다  
하지만 u와 nu는 엄연히 다른 타입이기에 u=== nu는 false가 된다  
메모리 위치가 다르다

## Object 타입 정리
### Object 타입의 특징
primitive type이 아닌 모든 것이 객체(참조형)이다

### property
property는 키(key)와 값(literal)의 쌍으로 이루어져 있다

### array도 객체다
array의 키는 index이다  
Object 타입은 모두 heap에 저장된다

## 형변환 (Type Conversion/Casting)
### toString()
```js
n=123;
n.toString() // "123" // 이 시점에서만 primitive type이 object 타입으로 변환된다
typeof n // "number" // 다시 primitive type으로 돌아온다
```
참고로 37진수로의 변형은 불가능하다(radix는 2~36까지만 허용됨)
```js
n.toString(37) // RangeError: toString() radix argument must be between 2 and 36
```

### parseInt / parseFloat
```js
parseInt(123.123) // 123
parseFloat("123.123abc") // 123.123
parseInt("abc") // NaN
parseInt(n.toString(16),16) // 123
```

### Boolean 변환
```js
const x=5;
Boolean(x) // true
!!x // true
```
위와 같이 Boolean()함수나 !!연산자를 사용해서 형변환을 할 수 있다

### Date 변환
```js
d= new Date();
d.toString() // 'Sun Nov 23 2025 19:38:24 GMT+0900 (Korean Standard Time)'
d.valueOf() // 1763894304531 // 유닉스 타임(유닉스가 태어난 1970년 1월 1일 0시 0분 0초부터 경과한 밀리초)
```

### 연산자와 형변환
```js
"sss"+{id:1} // "sss[object Object]"
{id:1}+2 // "[object Object]2"
1+"30" // "130"
1*"30" // 30
```
위와 같이 +연산자는 문자열 연결 연산자이기에 객체가 문자열로 변환된다  
반면에 *, /, -연산자는 산술 연산자이기에 객체가 숫자로 변환된다

```js
x=1;
x+ parseInt("30") // 31
x + Number("30.1") // 31.1
x + + '30.1' // 31.1
```
위와 같이 산술 연산자에서는 문자열이 숫자로 변환된다  
++연산자는 내부적으로 산술 연산자이기에 문자열이 숫자로 변환된다

## 암묵적인 형변환
```js
i=100;
i.toString() // "100"
10 +i.toString() // "10100"

let p='hong';
p.age=30; // 에러 발생할까?
// p를 자동으로 객체타입으로 형변환을 시켜준다
console.log(p.age); // undefined
// 그런데 undefined가 나온다 왜 그럴까?
```

위와 같이 p.age를 찍어보면 undefined가 나온다  
이는 p가 임시 객체로 변환되었기 때문이다  
해당 문에서만 객체로 변환이 되고  
다음 문장에서는 다시 원시 타입으로 돌아간다  
따라서 p.age는 존재하지 않기에 undefined가 나오는 것이다

i.toString()도 마찬가지이다  
i는 숫자 타입이기 때문에 100+10이면 110이 되어야 하지만  
i.toString()은 임시 String 객체로 변환이 되었기에 해당 문에 한정하여 "100"이 되고  
10+"100"이 되어 "10100"이 되는 것이다
