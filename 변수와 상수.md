# 변수와 메모리
변수는 변수 테이블에 저장된다
```js
var v=1;
```
위와 같이 선언되었을때 변수 v는 변수 테이블에 저장된다
이때 v의 주소값으로 저장된다
```js
v=2; 
```
이렇게 변경되었을떄, 변수 테이블에 저장된 v의 주소값이 가리키는 값이 2로 변경되고 1에 대한 연결이 끊어진다

# 스코프
var, function는 함수레벨스코프  
let, const는 블록레벨스코프  
추가로는 호이스팅 공부할때 상세히 알아보자

# Object/Reference Type
객체형/참조형  
객체형/참조형은 변수에 값이 아닌 주소값이 저장된다  
이건 Call by Reference 방식이다  
Heap에 저장된다  
Array, Date, RegExp, Map/WakeMap, Set/WeakSet, Function, Object  
properties & literals  
properties : key & value  
literals : {}, [], function(){}  
모든 코드는 literal로 표현가능하다

# Primitive/Value Type
원시형/값형  
메모리의 값은 변경되지 않는다  
값이 변경되면 해당 참조에 새로운 메모리가 할당된다  
이건 Call by Value 방식이다  
숫자(number,bigint), 문자열, 불리언  
undefined, null, symbol  
Stack에 저장된다

# Call by Value / Call by Reference
Call by Value
- 변수를 부르면 그 값을 리턴
Call by Reference
- 변수를 부르면 그 주소값을 리턴

# 값/참조 비교 예시
```
a=1  
b=1 
o1 = {id:1} // 메모리주소 : 0x100
o2 = {id:1} // 메모리주소 : 0x200
```
a와 b는 변수 테이블에 모두 저장된다  
값을 리턴하기에 그 리턴을 비교했을때 a==b는 true를 리턴한다  
타입도 같기에 a===b도 true를 리턴한다  

각각의 주소값 o1, o2가 가리키는 값은 같다  
하지만 o1과 o2는 각각 다른 주소값을 가지기에 o1==o2는 false를 리턴한다  
o1과 o2의 타입도 같지만 각각 다른 주소값을 가지기에 o1===o2도 false를 리턴한다  

```
o3 = o1 // 메모리주소 : 0x100
```
다음과 같이 o3가 o1을 가리키게 되면 어떻게 될까  
o3가 가리키는 주소값은 o1과 같다  
따라서 o3==o1은 true를 리턴한다  
타입도 같고 주소값도 같기에 o3===o1도 true를 리턴한다  

# null
null은 primitive type이다
```java
Dog d = new Dog('lucy');
// d를 메모리해제시키고 싶으면 
d = null;
```
객체가 비어있음을 명시적으로 표현할때 사용한다  
null은 개발자가 명시적으로 사용하도록 권장하고 있다

# NaN
NaN은 Not a Number의 약자이다  
숫자가 아님을 표현할때 사용한다  
데이터 영역에 상수로 존재한다

# undefined
undefined는 primitive type이다  
undefined는 개발자가 사용하지 않고 자바스크립트 엔진이 내부적으로 사용하도록 권장하고 있다  
undefined는 inner slice가 아니다  
inner slice란 자바스크립트만 사용가능한 공간을 말한다

# null, undefined, NaN 공통점
셋다 falsy 값이다  
falsy 값이란 boolean context에서 false로 평가되는 값을 말한다  
데이터 영역에 상수로 존재한다  
종착지라는 공통점이 있다

```js
typeof null // "object" -> 자바스크립트의 의도적 버그
obj = null;
typeof obj // "object"
```
null의 타입을 확인하면 object가 나온다  
이는 자바스크립트의 의도적인 버그이다  
null은 primitive type이다  
객체가 비어있음을 표현하기 위해 object로 잘못 표기되도록 설계되었다  
따라서 obj가 object이고 null이 아닌것을 같이 확인해야 한다
```js
obj !== null && typeof obj === "object"
```

# JSON과 Object가 같은가?
JSON은 JavaScript Object Notation일 뿐이다  
따라서 JSON과 Object는 다르다  
JSON은 데이터를 주고받기 위한 약속이라고 생각하면 된다

# String 객체 vs 문자열 리터럴
```js
s1= new String("xxx");
s2= "xxx";
s1 == s2 // true
s1 === s2 // false
```
위와 같이 String 객체와 문자열 리터럴을 비교했을때 ==는 true를 리턴하지만 ===는 false를 리턴한다  
String 객체는 객체형/참조형이다  
문자열 리터럴은 원시형/값형이다  
따라서 ==는 값만 비교하기에 true를 리턴한다  
그러나 ===는 타입까지  비교하기에 false를 리턴한다  
왜냐  
s1은 객체형/참조형이고 s2는 원시형/값형이기 때문이다

# string (문자열은 왜 primitive type일까?)
```java
String s = 'hello'; // 이렇게 new 키워드 없이 선언하는 타입들은 primitive type이다
```
이런 primitive type들은 constant pool에 저장된다  
constant pool은 메모리 절약을 위해 동일한 값이 여러번 사용되었을때 하나의 메모리 주소를 가리키도록 최적화하는 공간이다

```js
node --allow-natives-syntax
a= "hello, world"
%DebugPrint(a) // 0x9990980691 
// node를 Debug하기 위한 내부명령어
// 이런건 js conference에서나 다루기 떄문에 조회수 높은거 찾아서 공부해보자
b= "hello, world"
%DebugPrint(b) // 0x9990980691
```

```shell
DebugPrint: 0xc6528d48bf9: [String] in OldSpace: #hello, world
0x9990980691: [Map] in ReadOnlySpace # 수정을 못한다
 - map: 0x009990980841 <MetaMap (0x009990980099 <null>)>
 - type: INTERNALIZED_ONE_BYTE_STRING_TYPE # 1바이트 string 타입(영문, 영문이 아니면 적어도 2바이트 스트링 타입)
 - instance size: variable # 가변
 - elements kind: HOLEY_ELEMENTS 
 - enum length: invalid
 - stable_map
 - non-extensible
 - back pointer: 0x009990980069 <undefined>
 - prototype_validity cell: 0
 - instance descriptors (own) #0: 0x009990980c91 <DescriptorArray[0]>
 - prototype: 0x009990980099 <null>
 - constructor: 0x009990980099 <null>
 - dependent code: 0x009990980c51 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0
```
이떄 리턴값은 둘다 0x9990980691이다(예시)  
자바스크립트 엔진은 동일한 문자열 리터럴이 여러번 사용되었을때 메모리를 절약하기 위해 Constant Pool에 동일한 메모리 주소를 가리키도록 최적화를 한다  
따라서 문자열은 primitive type으로 설계되었다

# 해싱이란
```
(255).toString(2) // "11111111"
(255).toString(8) // "377"
(255).toString(16) // "ff"
(255).toString(36) // "73"
```
위와 같이 진법이 클수록 저장공간이 작아진다  
이렇게 값을 작게 만드는것을 해싱이라고 한다  
Base64는 64진수로 해싱하는 방법이다  
대표적인게 이미지를 Base64로 인코딩하는 방법이 있다

이렇게 해싱된 값을 키값으로 사용하여 데이터를 빠르게 검색하는 방법이 해시테이블이다  
원천 데이터는 heap에 있겠다 왜냐 가변데이터니까

# 왜 원천 데이터는 가변적일까?
왜 원천 데이터는 가변적일까?  
원천 데이터(문자열, 배열, 객체 등)는 그 크기를 미리 예측할 수 없기 때문에 가변적이다.

1. **데이터의 크기를 예측할 수 없음**
   - 문자열의 길이, 배열의 크기, 객체의 속성 개수 등이 런타임에 결정됨
   - 컴파일 타임에 메모리 크기를 확정할 수 없음

2. **동적으로 변경 가능**
   ```js
   const obj = {name: 'John'}; // 처음 크기
   obj.age = 30; // 속성 추가로 크기 증가
   obj.address = 'Seoul'; // 또 증가
   ```

3. **Stack의 한계**
   - Stack은 **고정 크기**의 데이터만 저장 가능
   - Stack은 크기가 제한적 (보통 1~2MB)
   - 함수 호출, 지역 변수 등 빠른 접근이 필요한 작은 데이터에 사용

**해시 테이블과의 관계**  
해시 테이블은 **고정 크기의 키(해시값)**만 저장:
- 해시값: 고정 길이 (예: 32bit, 64bit) → Stack
- 원천 데이터: 가변 길이 → Heap

```js
const data = "매우 긴 문자열..."; // Heap에 저장
const hash = hashFunction(data); // 고정 크기 해시값 → Stack에 저장
```

해시테이블은 stack에 있겠다 왜냐 고정데이터니까